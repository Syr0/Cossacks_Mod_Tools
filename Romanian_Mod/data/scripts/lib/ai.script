//
// ai.script
//

// _ai_IsEnemiesExists
//
function _ai_IsEnemiesExists(const plInd : Integer) : Boolean;
begin
   Result := False;
   var i : Integer;
   for i:=0 to gc_MaxPlayerCount-1 do
   begin
      if (i<>plInd) and (gPlayer[i].bexists) and (gPlayer[i].team <> gPlayer[plInd].team) then
      begin
         Result := True;
         break;
      end;
   end;
end;

// _ai_GetArmyUnit
//
function _ai_GetArmyUnit(pArmy : Pointer) : Integer;
begin
   Result := 0;
   if (pArmy <> nil) and (TArmy(pArmy).fSquadList.GetCount > 0) then
   begin
      var pSquad : Pointer = TArmy(pArmy).fSquadList.GetPointer(0);
      if (pSquad<>nil) then
      Result := TSquad(pSquad).Get(0);
   end;
end;

// _ai_GetArmyMoveCount
//
function _ai_GetArmyMoveCount(pArmy : Pointer) : Integer;
begin
   Result := 0;
   if pArmy <> nil then
   begin
      var i : Integer;
      for i := TArmy(pArmy).fSquadList.GetCount-1 downto 0 do
      begin
         var pSquad : Pointer = TArmy(pArmy).fSquadList.GetPointer(i);
         if pSquad<>nil then
         Result := Result + TSquad(pSquad).fMoveCount;
      end;
   end;
end;

// _ai_GetArmyUnitsCount
//
function _ai_GetArmyUnitsCount(pArmy : Pointer) : Integer;
begin
   Result := 0;
   if pArmy <> nil then
   begin
      var i : Integer;
      for i := TArmy(pArmy).fSquadList.GetCount-1 downto 0 do
      begin
         var pSquad : Pointer = TArmy(pArmy).fSquadList.GetPointer(i);
         if pSquad <> nil then
         Result := Result + TSquad(pSquad).GetCount;
      end;
   end;
end;

// _ai_GetArmyAttackCount
//
function _ai_GetArmyAttackCount(pArmy : Pointer) : Integer;
begin
   Result := 0;
   if pArmy <> nil then
   begin
      var i : Integer;
      for i := TArmy(pArmy).fSquadList.GetCount-1 downto 0 do
      begin
         var pSquad : Pointer = TArmy(pArmy).fSquadList.GetPointer(i);
         if pSquad <> nil then
         Result := Result + TSquad(pSquad).fAttackCount;
      end;
   end;
end;

// _ai_GetArmyDelayCount
//
function _ai_GetArmyDelayCount(pArmy : Pointer) : Integer;
begin
   Result := 0;
   if pArmy <> nil then
   begin
      var i : Integer;
      for i := TArmy(pArmy).fSquadList.GetCount-1 downto 0 do
      begin
         var pSquad : Pointer = TArmy(pArmy).fSquadList.GetPointer(i);
         if pSquad <> nil then
         Result := Result + TSquad(pSquad).fDelayCount;
      end;
   end;
end;

// _ai_GetUnitArmySpec
//
function _ai_GetUnitArmySpec(goHnd : Integer) : Integer;
begin
   var pObjProp : Pointer = _unit_GetObjProp(goHnd);
   if pObjProp <> nil then
   begin
      case TObjProp(pObjProp).usage of
         gc_obj_usage_grenadier : Result := gc_ai_armyspec_grenadier;
         gc_obj_usage_galley : Result := gc_ai_armyspec_galley;
         gc_obj_usage_frigate, gc_obj_usage_yacht : Result := gc_ai_armyspec_frigate;
         gc_obj_usage_battleship : Result := gc_ai_armyspec_battleship;
         gc_obj_usage_transport : Result := gc_ai_armyspec_transport;
         else Result := gc_ai_armyspec_default;
      end;
   end
   else
   Result := gc_ai_armyspec_default;
end;

procedure _ai_GetCommonNationName(const cid : Integer; var commonName : String; const isCommon : Boolean);
begin
   commonName := '';
   if (not isCommon) then
   _country_GetSIDByID(cid, commonName)
   else
   begin
      const _aus = 0;
      const _fra = 1;
      const _eng = 2;
      const _spa = 3;
      const _rus = 4;
      const _ukr = 5;
      const _pol = 6;
      const _swe = 7;
      const _pru = 8;
      const _ven = 9;
      const _tur = 10;
      const _alg = 11;
      const _mis = 12;
      const _net = 13;
      const _den = 14;
      const _por = 15;
      const _pie = 16;
      const _sax = 17;
      const _bav = 18;
      const _hun = 19;
      const _swi = 20;
      const _sco = 21;
      const _rom = 22;
      const _lit = 23;
      var aus, fra, eng, spa, rus, ukr, pol, swe, pru, ven, tur, alg, mis, net, den, por, pie, sax, bav, hun, swi, sco, rom, lit : Boolean;
      _country_IDToBoolean(cid, aus, fra, eng, spa, rus, ukr, pol, swe, pru, ven, tur, alg, mis, net, den, por, pie, sax, bav, hun, swi, sco, rom, lit);
      
      if (rus) or (ukr) then commonName := 'rus'
      else
      if (tur) or (alg) then commonName := 'tur'
      else
      if (mis) then commonName := 'mis'
      else
      commonName := 'eur';
   end;
end;

procedure _ai_GetMineUpgradeName(const cid, airole, upglevel : Integer; var upgsid : String);
begin
   var commonName : String = 'eur';
   //_ai_GetCommonNationName(cid, commonName, true);
   case airole of
      gc_ai_unit_minegold : upgsid := commonName+'gol.'+IntToStr(upglevel);
      gc_ai_unit_mineiron : upgsid := commonName+'iro.'+IntToStr(upglevel);
      gc_ai_unit_minecoal : upgsid := commonName+'coa.'+IntToStr(upglevel);
   end;
end;

procedure _ai_GetTowerUpgradeName(const cid, upglevel : Integer; var upgsid : String);
begin
   var commonName : String;
   _ai_GetCommonNationName(cid, commonName, true);
   upgsid := commonName+'tow.'+IntToStr(upglevel);
end;

procedure _ai_AddUniqUpgradeItem(const plind, cid, airole : Integer);
begin
   var p : Pointer = gPlayer[plind].aidata.uniqupg[cid].Add;
   if (p<>nil) then
   begin
      var id : Integer = gPlayer[plind].aidata.aiunit[cid][airole];
      TUniqUpgrade(p).cid := cid;
      TUniqUpgrade(p).unitid := id;
      TUniqUpgrade(p).airole := airole;
      var i : Integer;
      for i:=1 to 6 do
      begin
         var upgsid : String;
         if ((airole=gc_ai_unit_minegold) or (airole=gc_ai_unit_mineiron) or (airole=gc_ai_unit_minecoal)) then
         _ai_GetMineUpgradeName(cid, airole, i, upgsid);
         if (airole=gc_ai_unit_tower) then
         _ai_GetTowerUpgradeName(cid, i, upgsid);
         var upgid : Integer = _country_GetUpgradeIndexByUpgradeID(cid, upgsid, False);
         TUniqUpgrade(p).levelid[i] := upgid;
         TUniqUpgrade(p).levelsid[i] := upgsid;
      end;
   end;
end;

procedure _ai_FillUniqUpgradesList(const plind : Integer);
begin
   var i : Integer;
   for i:=0 to gc_MaxCountryCount-1 do
   begin
      _ai_AddUniqUpgradeItem(plind, i, gc_ai_unit_minegold);
      _ai_AddUniqUpgradeItem(plind, i, gc_ai_unit_mineiron);
      _ai_AddUniqUpgradeItem(plind, i, gc_ai_unit_minecoal);
      _ai_AddUniqUpgradeItem(plind, i, gc_ai_unit_tower);
   end;
end;

procedure _ai_FillOreList(const plind : Integer);
begin
   var plHnd : Integer = GetPlayerHandleByIndex(gc_playerind_env);
   gPlayer[plind].aidata.orelist.Clear;
   var i : Integer;
   for i:=GetPlayerGameObjectsCountByHandle(plHnd)-1 downto 0 do
   begin
      var goHnd : Integer = GetGameObjectHandleByIndex(i, plHnd);
      if (GetGameObjectVisibleByHandle(goHnd)) then
      begin
         if (_misc_GetBaseObjID(goHnd)=gc_baseid_res) then
         begin
            var pres : Pointer = _misc_GetObjectArgData(goHnd, gc_argenv_res);
            if (pres<>nil) then
            begin
               if ((TRes(pres).itype=gc_resource_type_gold) or (TRes(pres).itype=gc_resource_type_iron) or (TRes(pres).itype=gc_resource_type_coal)) then
               begin
                  gPlayer[plind].aidata.orelist.Add(goHnd);
                  var x : Float = GetGameObjectPositionXByHandle(goHnd);
                  var z : Float = GetGameObjectPositionZByHandle(goHnd);
               end;
            end;
         end;
      end;
   end;
end;

procedure _ai_FillUnitUpgradeListAddItem(const plind, cid, airole : Integer; const place : String);
begin
   var unitid : Integer = gPlayer[plind].aidata.aiunit[cid][airole];
   if (unitid<>-1) then
   begin
      var usid : String = gObjProp[cid][unitid].sid;
      var csid : String;
      _country_GetSIDByID(cid, csid);
      var basesid : String = csid+place+'.'+usid;
      gPlayer[plind].aidata.unitupg[cid][airole].unitid := unitid;
      //filling attack list
      var count : Integer;
      var i : Integer;
      for i:=1 to gc_ai_maxupgradelevel-1 do
      begin
         var upgsid : String = basesid+'.1.'+IntToStr(i);
         var upgid : Integer = _country_GetUpgradeIndexByUpgradeID(cid, upgsid, False);
         if (upgid>0) then
         begin
            gPlayer[plind].aidata.unitupg[cid][airole].attackupgradeid[i] := upgid;
            count := count+1;
         end
         else
         begin
            gPlayer[plind].aidata.unitupg[cid][airole].attackupgrade := count;
            break;
         end;
      end;
      //defence
      count := 0;
      for i:=1 to gc_ai_maxupgradelevel-1 do
      begin
         var upgsid : String = basesid+'.2.'+IntToStr(i);
         var upgid : Integer = _country_GetUpgradeIndexByUpgradeID(cid, upgsid, False);
         if (upgid>0) then
         begin
            gPlayer[plind].aidata.unitupg[cid][airole].defenceupgradeid[i] := upgid;
            count := count+1;
         end
         else
         begin
            gPlayer[plind].aidata.unitupg[cid][airole].defenceupgrade := count;
            break;
         end;
      end;
   end;
end;

procedure _ai_FillUnitUpgradeList(const plind : Integer);
begin
   var cid : Integer;
   for cid:=0 to gc_MaxCountryCount-1 do
   begin
      _ai_FillUnitUpgradeListAddItem(plind, cid, gc_ai_unit_officer17, 'bar');
      _ai_FillUnitUpgradeListAddItem(plind, cid, gc_ai_unit_drummer17, 'bar');
      _ai_FillUnitUpgradeListAddItem(plind, cid, gc_ai_unit_infantry17, 'bar');
      _ai_FillUnitUpgradeListAddItem(plind, cid, gc_ai_unit_musk17, 'bar');
      _ai_FillUnitUpgradeListAddItem(plind, cid, gc_ai_unit_reitar, 'sta');
      _ai_FillUnitUpgradeListAddItem(plind, cid, gc_ai_unit_cuirassier, 'sta');
      _ai_FillUnitUpgradeListAddItem(plind, cid, gc_ai_unit_grenadier, 'ba2');
      _ai_FillUnitUpgradeListAddItem(plind, cid, gc_ai_unit_musk18, 'ba2');
      _ai_FillUnitUpgradeListAddItem(plind, cid, gc_ai_unit_cannon, 'art');
      _ai_FillUnitUpgradeListAddItem(plind, cid, gc_ai_unit_howitzer, 'art');
      _ai_FillUnitUpgradeListAddItem(plind, cid, gc_ai_unit_dragun18, 'sta');
      //added 11.08
      _ai_FillUnitUpgradeListAddItem(plind, cid, gc_ai_unit_uniq_inf17, 'bar');
      _ai_FillUnitUpgradeListAddItem(plind, cid, gc_ai_unit_uniq_inf18, 'ba2');
      _ai_FillUnitUpgradeListAddItem(plind, cid, gc_ai_unit_uniq_cav17, 'sta');
      _ai_FillUnitUpgradeListAddItem(plind, cid, gc_ai_unit_uniq_cav18, 'sta');
      _ai_FillUnitUpgradeListAddItem(plind, cid, gc_ai_unit_hussar, 'sta');
      _ai_FillUnitUpgradeListAddItem(plind, cid, gc_ai_unit_dragoon17, 'sta');
      //added 170411
      var csid : String;
      _country_GetSIDByID(cid, csid);
      if (csid='sco') then
      _ai_FillUnitUpgradeListAddItem(plind, cid, gc_ai_unit_archer, 'ba2')
      else
      _ai_FillUnitUpgradeListAddItem(plind, cid, gc_ai_unit_archer, 'bar');
      _ai_FillUnitUpgradeListAddItem(plind, cid, gc_ai_unit_pikeman18, 'ba2');
   end;
end;

procedure _ai_GetUpgradeSID(const cid : Integer; const baseid : String; var sid : String);
begin
   var nationname : String;
   if ((baseid=gc_ai_upg_sid_food140) or (baseid=gc_ai_upg_sid_food250) {or (baseid=gc_ai_upg_sid_century)}) then
   _ai_GetCommonNationName(cid, nationname, true)
   else
   _ai_GetCommonNationName(cid, nationname, false);
   sid := nationname+baseid;
end;

procedure _ai_FillUpgradeIdListAddItem(const plind, cid, aiupgrade : Integer; const basesid : String);
begin
   var sid : String;
   _ai_GetUpgradeSID(cid, basesid, sid);
   gPlayer[plind].aidata.upgradeid[cid][aiupgrade] := _country_GetUpgradeIndexByUpgradeID(cid, sid, false);
end;

procedure _ai_FillUpgradeIdList(const plind, cid : Integer);
begin
   _ai_FillUpgradeIdListAddItem(plind, cid, gc_ai_upg_whead1, gc_ai_upg_sid_whead1);
   _ai_FillUpgradeIdListAddItem(plind, cid, gc_ai_upg_whead2, gc_ai_upg_sid_whead2);
   _ai_FillUpgradeIdListAddItem(plind, cid, gc_ai_upg_whead3, gc_ai_upg_sid_whead3);
   _ai_FillUpgradeIdListAddItem(plind, cid, gc_ai_upg_feelds, gc_ai_upg_sid_feelds);
   _ai_FillUpgradeIdListAddItem(plind, cid, gc_ai_upg_fish, gc_ai_upg_sid_fish);
   _ai_FillUpgradeIdListAddItem(plind, cid, gc_ai_upg_frigate, gc_ai_upg_sid_frigate);
   _ai_FillUpgradeIdListAddItem(plind, cid, gc_ai_upg_boats, gc_ai_upg_sid_boats);
   _ai_FillUpgradeIdListAddItem(plind, cid, gc_ai_upg_wood, gc_ai_upg_sid_wood);
   _ai_FillUpgradeIdListAddItem(plind, cid, gc_ai_upg_bricks1, gc_ai_upg_sid_bricks1);
   _ai_FillUpgradeIdListAddItem(plind, cid, gc_ai_upg_builders, gc_ai_upg_sid_builders);
   _ai_FillUpgradeIdListAddItem(plind, cid, gc_ai_upg_fort, gc_ai_upg_sid_fort);
   _ai_FillUpgradeIdListAddItem(plind, cid, gc_ai_upg_powder10, gc_ai_upg_sid_powder10);
   _ai_FillUpgradeIdListAddItem(plind, cid, gc_ai_upg_powder15, gc_ai_upg_sid_powder15);
   _ai_FillUpgradeIdListAddItem(plind, cid, gc_ai_upg_powder20, gc_ai_upg_sid_powder20);
   _ai_FillUpgradeIdListAddItem(plind, cid, gc_ai_upg_powder30, gc_ai_upg_sid_powder30);
   _ai_FillUpgradeIdListAddItem(plind, cid, gc_ai_upg_art5, gc_ai_upg_sid_art5);
   _ai_FillUpgradeIdListAddItem(plind, cid, gc_ai_upg_art10, gc_ai_upg_sid_art10);
   _ai_FillUpgradeIdListAddItem(plind, cid, gc_ai_upg_artlife, gc_ai_upg_sid_artlife);
   _ai_FillUpgradeIdListAddItem(plind, cid, gc_ai_upg_mbarrel, gc_ai_upg_sid_mbarrel);
   _ai_FillUpgradeIdListAddItem(plind, cid, gc_ai_upg_accurency1, gc_ai_upg_sid_accurency1);
   _ai_FillUpgradeIdListAddItem(plind, cid, gc_ai_upg_healart, gc_ai_upg_sid_healart);
   _ai_FillUpgradeIdListAddItem(plind, cid, gc_ai_upg_geolog, gc_ai_upg_sid_geolog);
   _ai_FillUpgradeIdListAddItem(plind, cid, gc_ai_upg_stone100, gc_ai_upg_sid_stone100);
   _ai_FillUpgradeIdListAddItem(plind, cid, gc_ai_upg_stone200, gc_ai_upg_sid_stone200);
   _ai_FillUpgradeIdListAddItem(plind, cid, gc_ai_upg_balloon, gc_ai_upg_sid_balloon);
   _ai_FillUpgradeIdListAddItem(plind, cid, gc_ai_upg_healunit, gc_ai_upg_sid_healunit);
   _ai_FillUpgradeIdListAddItem(plind, cid, gc_ai_upg_accurency2, gc_ai_upg_sid_accurency2);
   _ai_FillUpgradeIdListAddItem(plind, cid, gc_ai_upg_shipspeed, gc_ai_upg_sid_shipspeed);
   _ai_FillUpgradeIdListAddItem(plind, cid, gc_ai_upg_battleship, gc_ai_upg_sid_battleship);
   _ai_FillUpgradeIdListAddItem(plind, cid, gc_ai_upg_shipbuild, gc_ai_upg_sid_shipbuild);
   _ai_FillUpgradeIdListAddItem(plind, cid, gc_ai_upg_quickshot1, gc_ai_upg_sid_quickshot1);
   _ai_FillUpgradeIdListAddItem(plind, cid, gc_ai_upg_cheapmusk, gc_ai_upg_sid_cheapmusk);
   _ai_FillUpgradeIdListAddItem(plind, cid, gc_ai_upg_quickshot2, gc_ai_upg_sid_quickshot2);
   _ai_FillUpgradeIdListAddItem(plind, cid, gc_ai_upg_armor1, gc_ai_upg_sid_armor1);
   _ai_FillUpgradeIdListAddItem(plind, cid, gc_ai_upg_baginet, gc_ai_upg_sid_baginet);
   _ai_FillUpgradeIdListAddItem(plind, cid, gc_ai_upg_newsteel, gc_ai_upg_sid_newsteel);
   _ai_FillUpgradeIdListAddItem(plind, cid, gc_ai_upg_reaper, gc_ai_upg_sid_reaper);
   _ai_FillUpgradeIdListAddItem(plind, cid, gc_ai_upg_bricks2, gc_ai_upg_sid_bricks2);
   _ai_FillUpgradeIdListAddItem(plind, cid, gc_ai_upg_horse, gc_ai_upg_sid_horse);
   _ai_FillUpgradeIdListAddItem(plind, cid, gc_ai_upg_inf18, gc_ai_upg_sid_inf18);
   _ai_FillUpgradeIdListAddItem(plind, cid, gc_ai_upg_horseswords, gc_ai_upg_sid_horseswords);
   _ai_FillUpgradeIdListAddItem(plind, cid, gc_ai_upg_armor2, gc_ai_upg_sid_armor2);
   _ai_FillUpgradeIdListAddItem(plind, cid, gc_ai_upg_food140, gc_ai_upg_sid_food140);
   _ai_FillUpgradeIdListAddItem(plind, cid, gc_ai_upg_food250, gc_ai_upg_sid_food250);
   _ai_FillUpgradeIdListAddItem(plind, cid, gc_ai_upg_century, gc_ai_upg_sid_century);
end;

function _ai_GetProductionBuildingId(const plind, cid, id : Integer) : Integer;
begin
   var sid : String = gCountry[cid].members[id];
   var i,j : Integer;
   Result := -1;
   for i:=0 to gc_country_maxfixedproduce-1 do
   begin
      for j:=0 to gc_country_fixedproduce_maxcount-1 do
      begin
         var prodsid : String = gCountry[cid].fixedproduce[i].build[j].id;
         if (SameText(prodsid, sid)) then
         begin
            Result := _unit_ConvertObjSIDToID(cid, gCountry[cid].fixedproduce[i].id);
            break;
         end;
      end;
   end;
end;

procedure _ai_FillBuildingProductionList(const plind : Integer);
begin
   var i,j : Integer;
   for i:=0 to gc_MaxCountryCount-1 do
   begin
      for j:=0 to gc_country_maxmembers-1 do
      begin
         var id : Integer = gPlayer[plind].aidata.aiunit[i][j];
         if (id>0) then
         gPlayer[plind].aidata.buildlink[i][j] := _ai_GetProductionBuildingId(plind, i, id);
      end;
   end;
end;

procedure _ai_InitInitialLists(const plind : Integer);
begin
   var i, j: Integer;
   var airole : Integer;
   for i:=0 to gc_MaxCountryCount-1 do
   for j:=0 to gc_country_maxmembers-1 do
   gPlayer[plind].aidata.aiunit[i][airole] := -1;
   
   for i:=0 to gc_MaxCountryCount-1 do
   begin
      for j:=0 to gc_country_maxmembers-1 do
      begin
         airole := gObjProp[i,j].airole;
         if (airole<>gc_ai_unit_none) then
         gPlayer[plind].aidata.aiunit[i][airole] := j;
      end;
   end;
   _ai_FillBuildingProductionList(plind);
   for i:=0 to gc_MaxCountryCount-1 do
   _ai_FillUpgradeIdList(plind, i);
   _ai_FillUnitUpgradeList(plind);
   _ai_FillOreList(plind);
   _ai_FillUniqUpgradesList(plind);
   if (gPlayer[plind].aidata.centerfound) then
   begin
      var i : Integer;
      for i:=gPlayer[plind].aidata.orelist.GetCount-1 downto 0 do
      begin
         var goHnd : Integer = gPlayer[plind].aidata.orelist.Get(i);
         var goX : Float = GetGameObjectPositionXByHandle(goHnd);
         var goZ : Float = GetGameObjectPositionZByHandle(goHnd);
         var dist : Float = VectorDistance(goX, 0, goZ, gPlayer[plind].aidata.centerx, 0, gPlayer[plind].aidata.centerz);
         SetGameObjectTagFloatByHandle(goHnd, dist);
      end;
      _misc_SortListByTagFloat(gPlayer[plind].aidata.orelist, 0, gPlayer[plind].aidata.orelist.GetCount-1);
   end;
   for i:=0 to gc_MaxCountryCount-1 do
   gPlayer[plind].aidata.developmentera[i] := 0;
end;

// _ai_IsWarLandUnit
//
function _ai_IsWarLandUnit(goHnd : Integer) : Boolean;
begin
   var pObj : Pointer = _unit_GetTObj(goHnd);
   if pObj <> nil then
   begin
      case gObjProp[TObj(pObj).cid][TObj(pObj).id].usage of
         gc_obj_usage_mortar, gc_obj_usage_cannon, gc_obj_usage_grenadier, gc_obj_usage_supermortar,
         gc_obj_usage_lightinfantry, gc_obj_usage_shooter, gc_obj_usage_hardhorse, gc_obj_usage_horseshooter,
         gc_obj_usage_archer : Result := true
         else
         Result := false;
      end;
   end
   else
   Result := false;
end;

// _ai_GetArmyTypeByUsage
//
function _ai_GetArmyTypeByUsage(usage : Integer) : Integer;
begin
   case usage of
      gc_obj_usage_lightinfantry : Result := gc_ai_armytype_lightinfantry;
      gc_obj_usage_shooter : Result := gc_ai_armytype_shootinfantry;
      gc_obj_usage_fasthorse : Result := gc_ai_armytype_fasthorse;
      gc_obj_usage_hardhorse : Result := gc_ai_armytype_hardhorse;
      gc_obj_usage_horseshooter : Result := gc_ai_armytype_horseshooter;
      gc_obj_usage_cannon : Result := gc_ai_armytype_cannon;
      gc_obj_usage_grenadier : Result := gc_ai_armytype_grenadier;
      gc_obj_usage_peasant : Result := gc_ai_armytype_peasant;
      gc_obj_usage_weak : Result := gc_ai_armytype_weakunit;
      gc_obj_usage_supermortar : Result := gc_ai_armytype_supermortar;
      gc_obj_usage_mortar : Result := gc_ai_armytype_mortar;
      gc_obj_usage_archer : Result := gc_ai_armytype_archerinfantry;
      gc_obj_usage_galley : Result := gc_ai_armytype_galley;
      gc_obj_usage_frigate, gc_obj_usage_yacht : Result := gc_ai_armytype_frigate;
      gc_obj_usage_battleship : Result := gc_ai_armytype_battleship;
      gc_obj_usage_transport : Result := gc_ai_armytype_transport;
      else Result := gc_ai_armytype_none;
   end;
end;

// _ai_GetUnitArmyType
//
function _ai_GetUnitArmyType(goHnd : Integer) : Integer;
begin
   if _misc_GetBaseObjID(goHnd) = gc_baseid_obj then
   begin
      var pObjProp : Pointer = _unit_GetObjProp(goHnd);
      Result := _ai_GetArmyTypeByUsage(TObjProp(pObjProp).usage);
   end
   else
   Result := gc_ai_armytype_none;
end;

// _ai_IsTeamAI
//
function _ai_IsTeamAI(team : Integer) : Boolean;
begin
   Result := false;
   var i : Integer;
   for i := 0 to gc_MaxPlayerCount-1 do
   if gPlayer[i].bExists and (gPlayer[i].team = team) and gPlayer[i].bAI then
   begin
      Result := true;
      break;
   end;
end;

// _ai_GetArmyCentralPosition
//
procedure _ai_GetArmyCentralPosition(pArmy : Pointer; var cx, cz, cDirX, cDirZ : Float);
begin
   if pArmy <> nil then
   begin
      cx := 0;
      cz := 0;
      var i, j : Integer;
      var count : Integer;
      for i := TArmy(pArmy).fSquadList.GetCount-1 downto 0 do
      begin
         var pSquad : Pointer = TArmy(pArmy).fSquadList.GetPointer(i);
         if (pSquad <> nil) and (TSquad(pSquad).GetCount > 0) then
         begin
            var x, z : Float;
            _squad_GetCentralPosition(pSquad, x, z);
            var uCount : Integer = TSquad(pSquad).GetCount;
            cx := cx + x * uCount;
            cz := cz + z * uCount;
            count := count + uCount;
         end;
      end;
      
      if count > 0 then
      begin
         cx := cx/count;
         cz := cz/count;
      end;
   end;
end;

// _ai_GetArmyCentralPosAndDir
//
procedure _ai_GetArmyCentralPosAndDir(pArmy : Pointer; var cx, cz, cDirX, cDirZ : Float);
begin
   if pArmy <> nil then
   begin
      cx := 0;
      cz := 0;
      var i, j : Integer;
      var count : Integer;
      var unitCount : Integer;
      for i := TArmy(pArmy).fSquadList.GetCount-1 downto 0 do
      begin
         var pSquad : Pointer = TArmy(pArmy).fSquadList.GetPointer(i);
         if (pSquad<>nil) and (TSquad(pSquad).GetCount > 0) then
         begin
            var x, z, dirX, dirZ : Float;
            _squad_GetCentralPosition(pSquad, x, z);
            var uCount : Integer = TSquad(pSquad).GetCount;
            cx := cx + x * uCount;
            cz := cz + z * uCount;
            cDirX := cDirX + TSquad(pSquad).fDirX;
            cDirZ := cDirZ + TSquad(pSquad).fDirZ;
            count := count+1;
            unitCount := unitCount + uCount;
         end;
      end;
      
      if count > 0 then
      begin
         cx := cx / unitCount;
         cz := cz / unitCount;
         cDirX := cDirX / count;
         cDirZ := cDirZ / count;
         
         var len : Float = VectorLength(cDirX, 0, cDirZ);
         if len > 0 then
         begin
            cDirX := cDirX / len;
            cDirZ := cDirZ / len;
         end
         else
         begin
            cDirX := 1;
            cDirZ := 0;
         end;
      end;
   end;
end;

// _ai_SetSquadListPosition
//
procedure _ai_SetSquadListPosition(var list : TPtrList; posX, posZ, dirX, dirZ : Float; var cenX, cenZ : Float; mode : Integer);
begin
   var sqCount : Integer = list.GetCount;
   var aCols : Integer = MathCeil(Sqrt(sqCount));
   var aRows : Integer = MathCeil(sqCount/aCols);
   var i : Integer;
   var dirY : Float;
   if VectorLength(dirX, dirY, dirZ) = 0 then
   begin
      var curX, curZ : Float;
      for i := 0 to sqCount-1 do
      begin
         curX := curX + TSquad(list.GetPointer(i)).fCurX;
         curZ := curZ + TSquad(list.GetPointer(i)).fCurZ;
      end;
      
      curX := curX / sqCount;
      curZ := curZ / sqCount;
      
      dirX := posX - curX;
      dirZ := posZ - curZ;
      if VectorLength(dirX, dirY, dirZ) = 0 then
      begin
         dirX := 1;
         dirZ := 0;
      end
   end;
   
   VectorNormalize(dirX, dirY, dirZ);
   
   var hDirX : Float = dirX;
   var hDirY : Float;
   var hDirZ : Float = dirZ;
   VectorRotateY(hDirX, hDirY, hDirZ, 90);
   
   var count : Integer;
   for i := 0 to sqCount-1 do
   begin
      var pSquad : Pointer = list.GetPointer(i);
      var sCount : Integer = TSquad(pSquad).GetCount;
      var col : Integer = i mod aCols;
      var row : Integer = i div aCols;
      var offDir : Float = ((aRows-1)/2 - row) * gc_ai_army_offsetrow;
      var offHDir : Float = ((aCols-1)/2 - col) * gc_ai_army_offsetcol;
      
      var x : Float = posX + offHDir * hDirX + offDir * dirX;
      var z : Float = posZ + offHDir * hDirZ + offDir * dirZ;
      
      cenX := cenX + x * sCount;
      cenZ := cenZ + z * sCount;
      count := count + sCount;
      
      var topQuadTree : Integer = TopologyGetTopologyQuadTree;
      var topPrior : Integer = TopologyGetTopologyPriority;
      if not TraceLineQuadTree(posX, posZ, x, z, topPrior, topQuadTree) then
      begin
         x := posX;
         z := posZ;
      end;
      
      var plInd : Integer = TSquad(pSquad).fPlIndex;
      var plHnd : Integer = GetPlayerHandleByIndex(plInd);
      _player_SetSquadPosition(plHnd, TSquad(pSquad).fIndex, x, z, dirX, dirZ, false, true, mode, true);
   end;
   
   if count > 0 then
   begin
      cenX := cenX / count;
      cenZ := cenZ / count;
   end;
end;

// _ai_SetArmyPosition
//
procedure _ai_SetArmyPosition(pArmy : Pointer; posX, posZ, dirX, dirZ : Float; mode : Integer);
begin
   if pArmy <> nil then
   begin
      var dirY : Float;
      if VectorLength(dirX, dirY, dirZ) = 0 then
      begin
         dirX := posX - TArmy(pArmy).fCurX;
         dirZ := posZ - TArmy(pArmy).fCurZ;
         if VectorLength(dirX, dirY, dirZ) = 0 then
         begin
            dirX := 1;
            dirZ := 0;
         end
      end;
      
      var cenX, cenZ : Float;
      _ai_SetSquadListPosition(TArmy(pArmy).fSquadList, posX, posZ, dirX, dirZ, cenX, cenZ, mode);
      
      TArmy(pArmy).fX := posX;
      TArmy(pArmy).fZ := posZ;
      
      var tZone : Integer = TopologyGetZoneIndex(cenX, cenZ);
      if tZone >= 0 then
      TArmy(pArmy).fTopZone := tZone
      else
      TArmy(pArmy).fTopZone := TArmy(pArmy).fCurTopZone;
   end;
end;

// _ai_ArmyAlign
//
procedure _ai_ArmyAlign(pArmy : Pointer);
begin
   var plInd : Integer = TArmy(pArmy).fPlIndex;
   if IsInRangeInt(plInd, 0, gc_MaxPlayerCount-1) and (pArmy <> nil) then
   begin
      var i, j : Integer;
      var cx, cz, cDirX, cDirZ : Float;
      _ai_GetArmyCentralPosAndDir(pArmy, cx, cz, cDirX, cDirZ);
      
      var newZone : Integer = TopologyGetZoneIndex(cx, cz);
      if newZone <> TArmy(pArmy).fTopZone then
      begin
         var topdist : Integer = -1;
         var attackCount, unitCount : Integer;
         if (TArmy(pArmy).fTopZone>=0) then
         begin
            var dist : Float = VectorDistance(TArmy(pArmy).fX, 0, TArmy(pArmy).fZ, cx, 0, cz);
            attackCount := _ai_GetArmyAttackCount(pArmy);
            unitCount := _ai_GetArmyUnitsCount(pArmy);
            topdist := TopologyGetZonesGraphDist(newZone, TArmy(pArmy).fTopZone, 4);
         end;
         if (topdist>=0) and ((topdist < 3 {2}) or (attackCount = unitCount)) then
         begin
            if newZone >= 0 then
            TArmy(pArmy).fTopZone := newZone
            else
            TArmy(pArmy).fTopZone := TArmy(pArmy).fCurTopZone;
         end
         else
         _ai_SetArmyPosition(pArmy, cx, cz, cDirX, cDirZ, gc_obj_order_move_mode_default);
      end;
   end;
end;

// _ai_CalcEnemyArmies
//
procedure _ai_CalcEnemyArmies(pEnemyInfo : Pointer);
begin
   if pEnemyInfo <> nil then
   begin
      var i, j, i1, j1 : Integer;
      
      for i := 0 to gc_scangrid_countx-1 do
      for j := 0 to gc_scangrid_county-1 do
      begin
         //gArmyInfoCells[i, j].tag := 0;
         gArmyInfoCells[i, j].Reset;
         gArmyInfoCells[i, j].army := -1;
         gArmyInfoCells[i, j].region := -1;
      end;
      
      TEnemyInfo(pEnemyInfo).armyInfos.Clear;
      TEnemyInfo(pEnemyInfo).maxArmyForce := 0;
      var enMask : Integer = TEnemyInfo(pEnemyInfo).enemyMask;
      
      _misc_ProfilerBegin('_ai_CalcEnemyArmies:AllGameObjectsOfAllPlayers');
      for i := 0 to gc_MaxPlayerCount-1 do
      if gPlayer[i].bExists and (gPlayer[i].myPlMask and enMask <> 0) then
      begin
         var pobj : Pointer;
         var ix, iy, goHnd, usage, tag : Integer;
         var x, z : Float;
         var plHnd : Integer = GetPlayerHandleByIndex(i);
         for j := GetPlayerGameObjectsCountByHandle(plHnd)-1 downto 0 do
         begin
            goHnd := GetGameObjectHandleByIndex(j, plHnd);
            pobj := _unit_GetTObj(goHnd);
            if (pobj<>nil) then
            begin
               usage := gObjProp[TObj(pObj).cid][TObj(pObj).id].usage;
               tag := GetGameObjectStatesTagByHandle(goHnd);
               if (not TObj(pObj).bDead) and (((tag and gc_statetag_essential_none)<>0) or (usage = gc_obj_usage_tower)) and
               (tag and gc_statetag_visual_hide = 0) then
               begin
                  case usage of
                     gc_obj_usage_peasant, gc_obj_usage_lightinfantry, gc_obj_usage_shooter, gc_obj_usage_archer, gc_obj_usage_grenadier,
                     gc_obj_usage_fasthorse, gc_obj_usage_horseshooter, gc_obj_usage_hardhorse, gc_obj_usage_tower,
                     gc_obj_usage_mortar, gc_obj_usage_cannon, gc_obj_usage_supermortar, gc_obj_usage_mcannon,
                     gc_obj_usage_battleship, gc_obj_usage_fisher, gc_obj_usage_frigate, gc_obj_usage_galley,
                     gc_obj_usage_yacht, gc_obj_usage_xebec, gc_obj_usage_transport :
                     begin
                        x := GetGameObjectPositionXByHandle(goHnd);
                        z := GetGameObjectPositionZByHandle(goHnd);
                        if (_misc_PosToScanGridIndices(x, z, ix, iy)) then
                        begin
                           var zInd : Integer = TopologyGetZoneIndex(x, z);
                           var region : Integer = TopologyGetZoneRegionByIndex(zInd);
                           
                           if (region >= 0) and (gArmyInfoCells[ix, iy].region <> region) then
                           begin
                              case gArmyInfoCells[ix, iy].region of
                                 -1: gArmyInfoCells[ix, iy].region := region;
                                 -2: begin
                                    if gArmyInfoCells[ix, iy].regions.IndexOf(region) < 0 then
                                    gArmyInfoCells[ix, iy].regions.Add(region);
                                 end;
                                 else begin
                                    gArmyInfoCells[ix, iy].regions.Clear;
                                    gArmyInfoCells[ix, iy].regions.Add(gArmyInfoCells[ix, iy].region);
                                    gArmyInfoCells[ix, iy].regions.Add(region);
                                    gArmyInfoCells[ix, iy].region := -2;
                                 end;
                              end;
                           end;
                           
                           gArmyInfoCells[ix, iy].force := gArmyInfoCells[ix, iy].force + gObjProp[TObj(pObj).cid][TObj(pObj).id].aiforce;
                           gArmyInfoCells[ix, iy].checked := true;
                           
                           case usage of
                              gc_obj_usage_peasant:
                              gArmyInfoCells[ix, iy].infantry := gArmyInfoCells[ix, iy].infantry+1;
                              
                              gc_obj_usage_grenadier, gc_obj_usage_lightinfantry:
                              gArmyInfoCells[ix, iy].infantry := gArmyInfoCells[ix, iy].infantry+1;
                              
                              gc_obj_usage_shooter, gc_obj_usage_archer:
                              gArmyInfoCells[ix, iy].shooters := gArmyInfoCells[ix, iy].shooters+1;
                              
                              // DIFF: in original Cossacks horse archers didn't count
                              gc_obj_usage_fasthorse, gc_obj_usage_hardhorse, gc_obj_usage_horseshooter:
                              gArmyInfoCells[ix, iy].cavalry := gArmyInfoCells[ix, iy].cavalry+1;
                              
                              gc_obj_usage_cannon:
                              gArmyInfoCells[ix, iy].cannons := gArmyInfoCells[ix, iy].cannons+1;
                              
                              // DIFF: in original Cossacks super mortars didn't count
                              gc_obj_usage_mortar, gc_obj_usage_supermortar:
                              gArmyInfoCells[ix, iy].mortars := gArmyInfoCells[ix, iy].mortars+1;
                              
                              // DIFF: in original Cossacks multicanons didn't count
                              gc_obj_usage_mcannon:
                              gArmyInfoCells[ix, iy].mcannons := gArmyInfoCells[ix, iy].mcannons+1;
                              
                              gc_obj_usage_tower:
                              gArmyInfoCells[ix, iy].towers := gArmyInfoCells[ix, iy].towers+1;
                              
                              gc_obj_usage_battleship, gc_obj_usage_fisher, gc_obj_usage_frigate, gc_obj_usage_galley,
                              gc_obj_usage_yacht, gc_obj_usage_xebec, gc_obj_usage_transport :
                              gArmyInfoCells[ix, iy].ships := gArmyInfoCells[ix, iy].ships+1;
                           end;
                        end;
                     end;
                  end;
               end;
            end;
         end;
      end;
      _misc_ProfilerEnd('_ai_CalcEnemyArmies:AllGameObjectsOfAllPlayers');
      
      var x0, y0 : Integer;
      var curArmy : Integer;
      for x0 := 0 to gc_scangrid_countx-1 do
      for y0 := 0 to gc_scangrid_county-1 do
      if gArmyInfoCells[x0, y0].checked and (gArmyInfoCells[x0, y0].tag = 0) then
      begin
         var pArmyInfo : Pointer = TEnemyInfo(pEnemyInfo).armyInfos.Add;
         gArmyInfoCells[x0, y0].tag := 1;
         gArmyInfoCells[x0, y0].army := curArmy;
         TArmyInfo(pArmyInfo).IncludePos(x0, y0);
         TArmyInfo(pArmyInfo).IncludeRegions(gArmyInfoCells[x0, y0].region, gArmyInfoCells[x0, y0].regions);
         var isNeigh : Boolean = true;
         var rad : Integer = 1;
         
         while isNeigh do
         begin
            isNeigh := false;
            
            var minI : Integer = Max(-rad, -x0);
            var maxI : Integer = Min(rad, gc_scangrid_countx-1-x0);
            var minJ : Integer = Max(-rad, -y0);
            var maxJ : Integer = Min(rad, gc_scangrid_county-1-y0);
            
            for i := minI to maxI do
            for j := minJ to maxJ do
            if gArmyInfoCells[x0+i, y0+j].tag = 1 then
            begin
               var minI1 : Integer = Max(-1, -(x0+i));
               var maxI1 : Integer = Min(1, gc_scangrid_countx-1-(x0+i));
               var minJ1 : Integer = Max(-1, -(y0+j));
               var maxJ1 : Integer = Min(1, gc_scangrid_county-1-(y0+j));
               
               for i1 := minI1 to maxI1 do
               for j1 := minJ1 to maxJ1 do
               if ((i1 <> 0) or (j1 <> 0)) and gArmyInfoCells[x0+i+i1, y0+j+j1].checked and
               (gArmyInfoCells[x0+i+i1, y0+j+j1].tag = 0) then
               begin
                  gArmyInfoCells[x0+i+i1, y0+j+j1].tag := 1;
                  gArmyInfoCells[x0+i+i1, y0+j+j1].army := curArmy;
                  TArmyInfo(pArmyInfo).IncludePos(x0+i+i1, y0+j+j1);
                  TArmyInfo(pArmyInfo).IncludeRegions(gArmyInfoCells[x0+i+i1, y0+j+j1].region, gArmyInfoCells[x0+i+i1, y0+j+j1].regions);
                  isNeigh := true;
               end;
               
               gArmyInfoCells[x0+i, y0+j].tag := 2;
            end;
            
            if rad < Max(gc_scangrid_countx, gc_scangrid_county) then
            rad := rad+1;
         end;
         curArmy := curArmy+1;
      end;
      
      for i := 0 to gc_scangrid_countx-1 do
      for j := 0 to gc_scangrid_county-1 do
      if gArmyInfoCells[i, j].army >= 0 then
      begin
         var army : Integer = gArmyInfoCells[i, j].army;
         var pArmyInfo : Pointer = TEnemyInfo(pEnemyInfo).armyInfos.Get(army);
         
         TArmyInfo(pArmyInfo).infantry := TArmyInfo(pArmyInfo).infantry + gArmyInfoCells[i, j].infantry;
         TArmyInfo(pArmyInfo).shooters := TArmyInfo(pArmyInfo).shooters + gArmyInfoCells[i, j].shooters;
         TArmyInfo(pArmyInfo).cavalry := TArmyInfo(pArmyInfo).cavalry + gArmyInfoCells[i, j].cavalry;
         TArmyInfo(pArmyInfo).cannons := TArmyInfo(pArmyInfo).cannons + gArmyInfoCells[i, j].cannons;
         TArmyInfo(pArmyInfo).mortars := TArmyInfo(pArmyInfo).mortars + gArmyInfoCells[i, j].mortars;
         TArmyInfo(pArmyInfo).mcannons := TArmyInfo(pArmyInfo).mcannons + gArmyInfoCells[i, j].mcannons;
         TArmyInfo(pArmyInfo).towers := TArmyInfo(pArmyInfo).towers + gArmyInfoCells[i, j].towers;
         TArmyInfo(pArmyInfo).ships := TArmyInfo(pArmyInfo).ships + gArmyInfoCells[i, j].ships;
         TArmyInfo(pArmyInfo).force := TArmyInfo(pArmyInfo).force + gArmyInfoCells[i, j].force;
      end;
      
      for i := TEnemyInfo(pEnemyInfo).armyInfos.GetCount-1 downto 0 do
      begin
         var p : Pointer = TEnemyInfo(pEnemyInfo).armyInfos.Get(i);
         TArmyInfo(p).landCount := TArmyInfo(p).infantry + TArmyInfo(p).shooters + TArmyInfo(p).cavalry + TArmyInfo(p).cannons + TArmyInfo(p).mortars + TArmyInfo(p).mcannons + TArmyInfo(p).towers;
         TArmyInfo(p).waterCount := TArmyInfo(p).ships;
         
         if TArmyInfo(p).force > TEnemyInfo(pEnemyInfo).maxArmyForce then
         TEnemyInfo(pEnemyInfo).maxArmyForce := TArmyInfo(p).force;
         
         if TArmyInfo(p).region >= 0 then
         TArmyInfo(p).regions.Add(TArmyInfo(p).region);
      end;
   end;
end;

// _ai_UpdateEnemyInfo
//
procedure _ai_UpdateEnemyInfo(pEnInfo : Pointer);
begin
   if (pEnInfo <> nil) and TEnemyInfo(pEnInfo).changed then
   begin
      var i, j : Integer;
      var team : Integer = TEnemyInfo(pEnInfo).team;
      TEnemyInfo(pEnInfo).towers.Clear;
      
      for i := 0 to gc_scangrid_countx-1 do
      for j := 0 to gc_scangrid_county-1 do
      TEnemyInfo(pEnInfo).towerMap[i, j] := 0;
      
      var enMask : Integer;
      for i := 0 to gc_MaxPlayerCount-1 do
      if gPlayer[i].bExists and (gPlayer[i].team = team) then
      begin
         TEnemyInfo(pEnInfo).enemyMask := gPlayer[i].enemyPlMask;
         enMask := gPlayer[i].enemyPlMask;
         break;
      end;
      
      if enMask <> 0 then
      begin
         _misc_ProfilerBegin('_ai_UpdateEnemyInfo:AllGameObjectsOfAllPlayers');
         for i := 0 to gc_MaxPlayerCount-1 do
         if gPlayer[i].bExists and (gPlayer[i].myPlMask and enMask <> 0) then
         begin
            var count : Integer = gPlayer[i].lists.buildings.GetCount;
            for j := 0 to count-1 do
            begin
               var goHnd : Integer = gPlayer[i].lists.buildings.Get(j);
               var pObj : Pointer = _unit_GetTObj(goHnd);
               if gObjProp[TObj(pObj).cid][TObj(pObj).id].usage = gc_obj_usage_tower then
               TEnemyInfo(pEnInfo).towers.Add(goHnd);
            end;
         end;
         _misc_ProfilerEnd('_ai_UpdateEnemyInfo:AllGameObjectsOfAllPlayers');
      end;
      
      TEnemyInfo(pEnInfo).changed := false;
   end;
end;

// _ai_ProcessTowers
//
procedure _ai_ProcessTowers(pEnemyInfo : Pointer);
begin
   if pEnemyInfo <> nil then
   begin
      var i : Integer;
      for i := 0 to TEnemyInfo(pEnemyInfo).towers.GetCount-1 do
      begin
         var pTower : Pointer = TEnemyInfo(pEnemyInfo).towers.Get(i);
         if (TTower(pTower).radius >= 0) or (TTower(pTower).pause >= 0) then
         _unit_ProcessTower(pEnemyInfo, i);
      end;
   end;
end;

// _ai_ProcessEnemyInfo
//
procedure _ai_ProcessEnemyInfo(pEnemyInfo : Pointer);
begin
   if pEnemyInfo <> nil then
   begin
      _ai_CalcEnemyArmies(pEnemyInfo);
      _ai_ProcessTowers(pEnemyInfo);
   end;
end;

// _ai_CheckProcessEnemyInfo
//
procedure _ai_CheckProcessEnemyInfo(tick : Integer);
begin
   var i, team : Integer;
   var teams : Integer = gEnemyInfoList.GetCount;
   var tickStep : Integer = gc_ai_UpdateEnemyInfoTick div (teams+1);
   for team := 1 to teams do
   begin
      if tick mod gc_ai_UpdateEnemyInfoTick = tickStep * (team-1) then
      begin
         _misc_ProfilerBegin('progress._ai_CheckProcessEnemyInfo');
         var myTeam, enTeam : Boolean;
         var enMask : Integer;
         for i := 0 to gc_MaxPlayerCount-1 do
         if gPlayer[i].bExists then
         begin
            if gPlayer[i].team <> team then
            enTeam := true
            else
            if gPlayer[i].bAI then
            begin
               myTeam := true;
               enMask := gPlayer[i].enemyPlMask;
            end;
            
            if myTeam and enTeam then
            break;
         end;
         
         var pEnemyInfo : Pointer = _misc_GetTeamEnemyInfo(team);
         if pEnemyInfo <> nil then
         begin
            if myTeam and enTeam then
            begin
               if not TEnemyInfo(pEnemyInfo).enabled then
               begin
                  TEnemyInfo(pEnemyInfo).enabled := true;
                  TEnemyInfo(pEnemyInfo).changed := true;
               end
               else
               if enMask <> TEnemyInfo(pEnemyInfo).enemyMask then
               TEnemyInfo(pEnemyInfo).changed := true;
               
               if TEnemyInfo(pEnemyInfo).changed then
               _ai_UpdateEnemyInfo(pEnemyInfo);
               
               _ai_ProcessEnemyInfo(pEnemyInfo);
            end
            else
            if TEnemyInfo(pEnemyInfo).enabled then
            begin
               TEnemyInfo(pEnemyInfo).enabled := false;
               TEnemyInfo(pEnemyInfo).Reset;
            end;
         end;
         _misc_ProfilerEnd('progress._ai_CheckProcessEnemyInfo');
      end;
   end;
end;

// _ai_CreateMinimalArmy
//
function _ai_CreateMinimalArmy(plInd, armyType, maxUnits : Integer; var list : TIntegerList; checkEssential, checkAvail : Boolean) : Pointer;
begin
   Result := nil;
   var plHnd : Integer = GetPlayerHandleByIndex(plInd);
   
   var i : Integer;
   var pArmy : Pointer = nil;
   var maxCount : Integer = maxUnits;
   if maxUnits = 0 then
   maxCount := gAIConst.armyMaxCount[armyType];
   
   procedure AddSquad;
   begin
      var pSquad : Pointer = _player_WriteSquadNew(plHnd, -1, 0, 0, gPlayer[plInd].aiData.aiList, false, false);
      if (pSquad<>nil) then
      begin
         TArmy(pArmy).Add(pSquad);
         TSquad(pSquad).fType := armyType;
      end;
      
      gPlayer[plInd].aiData.aiList.Clear;
   end;
   
   gPlayer[plInd].aiData.aiList.Clear;
   
   for i := list.GetCount-1 downto 0 do
   begin
      var goHnd : Integer = list.Get(i);
      if (not checkEssential) or ((GetGameObjectStatesTagByHandle(goHnd) and gc_statetag_essential_none) <> 0) then
      begin
         var pObj : Pointer = _unit_GetTObj(goHnd);
         var id : Integer = TObj(pObj).id;
         var cid : Integer = TObj(pObj).cid;
         
         if (_ai_GetUnitArmyType(goHnd) = armyType) and ((not checkAvail) or gPlayer[plInd].aiData.avUnits[cid][id]) then
         begin
            if pArmy = nil then
            begin
               pArmy := gPlayer[plInd].aiData.armyList.AddSetup(plInd);
               if pArmy<>nil then
               TArmy(pArmy).fSpec := _ai_GetUnitArmySpec(goHnd);
            end;
            
            gPlayer[plInd].aiData.aiList.Add(goHnd);
            list.Delete(i);
            
            var aiCount : Integer = gPlayer[plInd].aiData.aiList.GetCount;
            if (aiCount > 0) and (aiCount >= maxCount) then
            begin
               AddSquad;
               break;
            end;
         end;
      end;
   end;
   
   if pArmy <> nil then
   begin
      if gPlayer[plInd].aiData.aiList.GetCount > 0 then
      AddSquad;
      
      var sqCount : Integer = TArmy(pArmy).fSquadList.GetCount;
      if sqCount = 0 then
      gPlayer[plInd].aiData.armyList.Remove(pArmy)
      else
      begin
         for i := TArmy(pArmy).fSquadList.GetCount-1 downto 0 do
         begin
            var pSquad : Pointer = TArmy(pArmy).fSquadList.GetPointer(i);
            if pSquad<>nil then
            _player_SetSquadFormation(plHnd, TSquad(pSquad).fIndex, TSquad(pSquad).fFormation, false, false);
         end;
      end;
   end;
   
   Result := pArmy;
end;

// _ai_ArmyAddSquad
//
procedure _ai_ArmyAddSquad(pArmy, pSquad : Pointer);
begin
   if (pArmy <> nil) and (pSquad <> nil) then
   begin
      var plInd : Integer = TArmy(pArmy).fPlIndex;
      var plHnd : Integer = GetPlayerHandleByIndex(plInd);
      
      // remove from old army
      if TSquad(pSquad).fArmy >= 0 then
      begin
         var pOldArmy : Pointer = gPlayer[plInd].aiData.armyList.Get(TSquad(pSquad).fArmy);
         TArmy(pOldArmy).Remove(pSquad)
      end;
      
      if TSquad(pSquad).fWarType <> 0 then
      begin
         TArmy(pArmy).Add(pSquad);
         TSquad(pSquad).fType := 0;
      end
      else
      if TSquad(pSquad).fFormation >= 0 then
      begin
         TArmy(pArmy).Add(pSquad);
      end
      else
      begin
         var sqInd : array [0..gc_ai_maxarmytypes-1] of Integer;
         var i, j : Integer;
         for i := 0 to gc_ai_maxarmytypes-1 do
         sqInd[i] := -1;
         
         var goCount : Integer = TSquad(pSquad).GetCount;
         for i := goCount-1 downto 0 do
         begin
            var goHnd : Integer = TSquad(pSquad).Get(i);
            if (goHnd<>0) then
            begin
               var aType : Integer = _ai_GetUnitArmyType(goHnd);
               if aType <> gc_ai_armytype_none then
               begin
                  var newSquad : Boolean;
                  if sqInd[aType] >= 0 then
                  begin
                     var pSquad1 : Pointer = TArmy(pArmy).fSquadList.GetPointer(sqInd[aType]);
                     if (pSquad1 <> nil) and (TSquad(pSquad1).GetCount >= gAIConst.armyMaxCount[aType]) then
                     begin
                        _squad_SetCustomFormation(pSquad1, true);
                        sqInd[aType] := -1;
                     end;
                  end;
                  
                  if sqInd[aType] < 0 then
                  begin
                     var aSquadCount : Integer = TArmy(pArmy).fSquadList.GetCount;
                     for j := 0 to aSquadCount-1 do
                     begin
                        var pSquad1 : Pointer = TArmy(pArmy).fSquadList.GetPointer(j);
                        
                        if (pSquad1<>nil) and (TSquad(pSquad1).fType = aType) and (TSquad(pSquad1).GetCount < gAIConst.armyMaxCount[aType]) and
                        (TSquad(pSquad1).fWarType = 0) and (TSquad(pSquad1).fFormation < 0) then
                        begin
                           sqInd[aType] := j;
                           break;
                        end;
                     end;
                  end;
                  
                  if sqInd[aType] < 0 then
                  begin
                     gPlayer[plInd].aiData.aiList.Clear;
                     var pNewSquad : Pointer = _player_WriteSquadNew(plHnd, -1, 0, 0, gPlayer[plInd].aiData.aiList, false, false);
                     if pNewSquad <> nil then
                     begin
                        TArmy(pArmy).Add(pNewSquad);
                        TSquad(pNewSquad).fType := aType;
                        
                        sqInd[aType] := TArmy(pArmy).fSquadList.GetCount-1;
                     end;
                  end;
                  
                  if (sqInd[aType] >= 0) then
                  begin
                     var pSquad1 : Pointer = TArmy(pArmy).fSquadList.GetPointer(sqInd[aType]);
                     if (pSquad1<>nil) then
                     begin
                        TSquad(pSquad).Delete(i);
                        
                        _squad_AddUnit(pSquad1, goHnd, false);
                     end;
                  end;
               end;
            end
            else
            ErrorLog('_ai_ArmyAddSquad : goHnd=0');
         end;
         
         for i := 0 to gc_ai_maxarmytypes-1 do
         if sqInd[i] >= 0 then
         begin
            var pSquad1 : Pointer = TArmy(pArmy).fSquadList.GetPointer(sqInd[i]);
            _squad_SetCustomFormation(pSquad1, true);
         end;
         
         if TSquad(pSquad).GetCount = 0 then
         begin
            var sqInd : Integer = TSquad(pSquad).fIndex;
            _misc_DisbandSquad(plHnd, sqInd, true);
         end
         else
         begin
            for i := TSquad(pSquad).fWidth-1 downto 0 do
            for j := TSquad(pSquad).fHeight-1 downto 0 do
            begin
               var goHnd : Integer = TSquad(pSquad).arGrid[i, j];
               var pObj : Pointer = _unit_GetTObj(goHnd);
               if pObj <> nil then
               begin
                  if TObj(pObj).squad <> TSquad(pSquad).fIndex then
                  TSquad(pSquad).arGrid[i, j] := 0;
               end;
            end;
         end;
      end;
   end;
end;

// _ai_ArmyClearOrder
//
procedure _ai_ArmyClearOrder(pArmy : Pointer);
begin
   if (pArmy<>nil) then
   begin
      case TArmy(pArmy).fSpec of
         gc_ai_armyspec_sabotage : TArmy(pArmy).fOrder.iType := gc_ai_armyorder_sabotage;
         gc_ai_armyspec_agressor : TArmy(pArmy).fOrder.iType := gc_ai_armyorder_agressor;
         else
         TArmy(pArmy).fOrder.iType := gc_ai_armyorder_none;
      end;
      
      _unit_SetArmyOrderTarget(pArmy, 0);
      TArmy(pArmy).fOrder.tag := 0;
      TArmy(pArmy).fOrder.tag2 := 0;
      TArmy(pArmy).fOrder.tag3 := 0;
      TArmy(pArmy).fOrder.tagFloat := 0;
   end
   else
   ErrorLog('_ai_ArmyClearOrder : pArmy=nil');
end;

// _ai_ArmyCancelOrders
//
procedure _ai_ArmyCancelOrders(pArmy : Pointer);
begin
   if (pArmy<>nil) then
   begin
      var i, j, k : Integer;
      for i := TArmy(pArmy).fSquadList.GetCount-1 downto 0 do
      begin
         var pSquad : Pointer = TArmy(pArmy).fSquadList.GetPointer(i);
         if (pSquad<>nil) then
         for j := TSquad(pSquad).GetCount-1 downto 0 do
         begin
            var goHnd : Integer = TSquad(pSquad).Get(j);
            //_unit_ClearOrders(goHnd);
            //_unit_Stop(goHnd);
            
            var pObj : Pointer = _unit_GetTObj(goHnd);
            if pobj<>nil then
            begin
               for k := gc_obj_MaxOrderCount-1 downto 0 do
               begin
                  if (TObj(pObj).orders[k].iType = gc_obj_order_type_attackobj) or (TObj(pObj).orders[k].iType = gc_obj_order_type_attackpoint) then
                  _unit_RemoveOrder(goHnd, k);
               end;
               if (not gObjProp[TObj(pObj).cid][TObj(pObj).id].bartillery) then // artillery often stop shooting on long range. with this check, art will shoot when possible
               TObj(pobj).bsearchenemy := False;
            end;
         end;
      end;
      
      _ai_ArmyClearOrder(pArmy);
      _ai_ArmyAlign(pArmy);
   end
   else
   ErrorLog('_ai_ArmyClearOrder : pArmy=nil');
end;

// _ai_GetBestVictimForArchers
//
function _ai_GetBestVictimForArchers(plInd, topZone : Integer; x, z, rad : Float) : Integer;
begin
   if IsInRangeInt(topZone, 0, TopologyGetZonesCount-1) then
   begin
      var enMask : Integer = gPlayer[plInd].enemyPlMask;
      var w : Integer = GetMapWidth;
      var h : Integer = GetMapHeight;
      var minX : Float = _misc_MaxFloat(x - gc_ai_MaxArcherGridSize * gc_ai_ArcherGridRes / 2, -w/2+1);
      var maxX : Float = _misc_MinFloat(x + gc_ai_MaxArcherGridSize * gc_ai_ArcherGridRes / 2, w/2-1);
      var minZ : Float = _misc_MaxFloat(z - gc_ai_MaxArcherGridSize * gc_ai_ArcherGridRes / 2, -h/2+1);
      var maxZ : Float = _misc_MinFloat(z + gc_ai_MaxArcherGridSize * gc_ai_ArcherGridRes / 2, h/2-1);
      
      var minGridX, minGridY : Integer;
      var maxGridX, maxGridY : Integer;
      _misc_PosToScanGridIndices(minX, minZ, minGridX, minGridY);
      _misc_PosToScanGridIndices(maxX, maxZ, maxGridX, maxGridY);
      
      const cMinWeightBarrier = 20;
      
      var i, j, k : Integer;
      for i := 0 to gc_ai_MaxArcherGridSize-1 do
      for j := 0 to gc_ai_MaxArcherGridSize-1 do
      begin
         gArcherGrid[i, j].weight := -cMinWeightBarrier;
         gArcherGrid[i, j].trgHnd := 0;
      end;
      
      for i := minGridX to maxGridX do
      for j := minGridY to maxGridY do
      begin
         var bestWeight : Float;
         if (enMask and gScanGrid[i, j].fPlMask<>0) then
         for k := gScanGrid[i, j].GetCount-1 downto 0 do
         begin
            var goHnd : Integer = gScanGrid[i, j].Get(k);
            var pObj : Pointer = _unit_GetTObj(goHnd);
            if pObj <> nil then
            begin
               var pObjProp : Pointer = gObjProp[TObj(pObj).cid][TObj(pObj).id];
               if (not TObjProp(pObjProp).bArtillery) and (not TObj(pObj).bDead) and
               (TObjProp(pObjProp).bBuilding or ((GetGameObjectStatesTagByHandle(goHnd) and gc_statetag_essential_none)<>0)) then
               begin
                  var plInd : Integer = TObj(pObj).pl;
                  var enPlayer : Boolean = (gPlayer[plInd].myPlMask and enMask <> 0);
                  var goX : Float = GetGameObjectPositionXByHandle(goHnd);
                  var goZ : Float = GetGameObjectPositionZByHandle(goHnd);
                  var aGridX, aGridY : Integer;
                  if goX > x then
                  aGridX := gc_ai_MaxArcherGridSize div 2 + Floor((goX-x)/gc_ai_ArcherGridRes)
                  else
                  aGridX := gc_ai_MaxArcherGridSize div 2 - Floor((x-goX)/gc_ai_ArcherGridRes)-1;
                  if goZ > z then
                  aGridY := gc_ai_MaxArcherGridSize div 2 + Floor((goZ-z)/gc_ai_ArcherGridRes)
                  else
                  aGridY := gc_ai_MaxArcherGridSize div 2 - Floor((z-goZ)/gc_ai_ArcherGridRes)-1;
                  
                  if IsInRangeInt(aGridX, 0, gc_ai_MaxArcherGridSize-1) and IsInRangeInt(aGridY, 0, gc_ai_MaxArcherGridSize-1) then
                  begin
                     if TObjProp(pObjProp).bWall and enPlayer then
                     begin
                        // TODO: not finished. Code for walls
                     end
                     else
                     if TObjProp(pObjProp).bBuilding then
                     begin
                        if enPlayer then
                        begin
                           var usage : Integer = TObjProp(pObjProp).usage;
                           var hp : Integer = TObj(pObj).hp; // shield factor
                           var addWeight : Float;
                           if (usage = gc_obj_usage_tower) or (usage = gc_obj_usage_mine) or (usage = gc_obj_usage_center) then
                           addWeight := 100 // 50
                           else
                           if ((TObjProp(pObjProp).bcapture) and (TObj(pobj).bbuilt)) and (not TObjProp(pObjProp).bmarket) then
                           addWeight := 0
                           else
                           if hp < 4000 then
                           addWeight := 40 // 30
                           else
                           if hp < 8000 then
                           addWeight := 30 // 20
                           else
                           if hp < 20000 then
                           addWeight := 12 // 8
                           else
                           addWeight := 5; // 3
                           
                           if (addWeight>0) then
                           begin
                              if (gArcherGrid[aGridX, aGridY].weight<0) then
                              gArcherGrid[aGridX, aGridY].weight := 0;
                              addWeight := addWeight/(1+(gPlayer[plInd].objbase[TObj(pObj).cid][TObj(pObj).id].shield div 100));
                              gArcherGrid[aGridX, aGridY].weight := gArcherGrid[aGridX, aGridY].weight + addWeight;
                              //gArcherGrid[aGridX, aGridY].trgHnd := goHnd;
                              if (addWeight>bestWeight) then
                              begin
                                 bestWeight := addWeight;
                                 gArcherGrid[aGridX, aGridY].trgHnd := goHnd;
                              end;
                           end;
                        end;
                     end
                     else
                     begin
                        var addWeight : Float;
                        if enPlayer then
                        begin
                           if (not TObjProp(pObjProp).bCapture) then
                           addWeight := 1
                           else
                           addWeight := 2;
                        end
                        else
                        begin
                           if (TObjProp(pObjProp).usage <> gc_obj_usage_shooter) and (TObjProp(pObjProp).usage <> gc_obj_usage_archer) then
                           addWeight := -1
                           else
                           addWeight := 0;
                        end;
                        
                        if addWeight <> 0 then
                        begin
                           var minI : Integer = Max(aGridX-1, 0);
                           var maxI : Integer = Min(aGridX+1, gc_ai_MaxArcherGridSize-1);
                           var minJ : Integer = Max(aGridY-1, 0);
                           var maxJ : Integer = Min(aGridY+1, gc_ai_MaxArcherGridSize-1);
                           
                           var i1, j1 : Integer;
                           for i1 := minI to maxI do
                           for j1 := minJ to maxJ do
                           gArcherGrid[i1, j1].weight := gArcherGrid[i1, j1].weight + addWeight;
                           
                           if enPlayer then
                           gArcherGrid[aGridX, aGridY].trgHnd := goHnd;
                        end;
                     end;
                  end;
               end;
            end;
         end;
      end;
      
      // get best victim
      var maxWeight : Float;
      var bestHnd : Integer;
      for i := 0 to gc_ai_MaxArcherGridSize-1 do
      for j := 0 to gc_ai_MaxArcherGridSize-1 do
      if (gArcherGrid[i, j].trgHnd <> 0) and (gArcherGrid[i, j].weight > 0) then
      begin
         var weight : Float = gArcherGrid[i, j].weight;
         var ix : Integer = i - gc_ai_MaxArcherGridSize div 2;
         var iy : Integer = j - gc_ai_MaxArcherGridSize div 2;
         var r : Float = VectorLength(ix, 0, iy);
         
         if r < 8 * gc_ai_ArcherArrayFactor then
         r := 8 * gc_ai_ArcherArrayFactor;
         if r > rad then
         r := 100000;
         
         weight := weight / r;
         if weight > maxWeight then
         begin
            var goHnd : Integer = gArcherGrid[i, j].trgHnd;
            var pObjProp : Pointer = _unit_GetObjProp(goHnd);
            if TObjProp(pObjProp).bWall then
            begin
               maxWeight := weight;
               bestHnd := goHnd;
            end
            else
            begin
               var goX : Float = GetGameObjectPositionXByHandle(goHnd);
               var goZ : Float = GetGameObjectPositionZByHandle(goHnd);
               var goZone : Integer = TopologyGetZoneIndex(goX, goZ);
               if goZone >= 0 then
               begin
                  var f : Boolean;
                  
                  if goZone = topZone then
                  f := true
                  else
                  begin
                     var tzDist : Integer = TopologyGetZonesGraphDist(goZone, topZone, -1);
                     f := IsInRangeInt(tzDist, 0, 80-1);
                  end;
                  
                  if f then
                  begin
                     maxWeight := weight;
                     bestHnd := goHnd;
                  end;
               end;
            end;
         end;
      end;
      
      Result := bestHnd;
   end
   else
   Result := 0;
end;

// _ai_ArmyHandleArchers
//
function _ai_ArmyHandleArchers(pArmy : Pointer; radius : Float) : Integer;
begin
   Result := 0;
   if pArmy<>nil then
   begin
      var i, j : Integer;
      var x, z : Float;
      var count : Integer;
      var plInd : Integer = TArmy(pArmy).fPlIndex;
      gPlayer[plInd].aiData.aiList.Clear;
      
      for i := TArmy(pArmy).fSquadList.GetCount-1 downto 0 do
      begin
         var pSquad : Pointer = TArmy(pArmy).fSquadList.GetPointer(i);
         if pSquad<>nil then
         for j := TSquad(pSquad).GetCount-1 downto 0 do
         begin
            var goHnd : Integer = TSquad(pSquad).Get(j);
            var pObj : Pointer = _unit_GetTObj(goHnd);
            
            if (gObjProp[TObj(pObj).cid][TObj(pObj).id].usage = gc_obj_usage_archer) then
            begin
               gPlayer[plInd].aiData.aiList.Add(goHnd);
               x := x + 16 * GetGameObjectPositionXByHandle(goHnd);
               z := z + 16 * GetGameObjectPositionZByHandle(goHnd);
               count := count+16;
            end
            else
            begin
               x := x + GetGameObjectPositionXByHandle(goHnd);
               z := z + GetGameObjectPositionZByHandle(goHnd);
               count := count+1;
            end;
         end;
      end;
      
      var archCount : Integer = gPlayer[plInd].aiData.aiList.GetCount;
      if archCount > 0 then
      begin
         x := x / count;
         z := z / count;
         var topZone : Integer = TArmy(pArmy).fTopZone;
         var trgHnd : Integer = _ai_GetBestVictimForArchers(plInd, topZone, x, z, radius);
         
         if trgHnd <> 0 then
         begin
            for i := gPlayer[plInd].aiData.aiList.GetCount-1 downto 0 do
            begin
               var goHnd : Integer = gPlayer[plInd].aiData.aiList.Get(i);
               var pobj : Pointer = _unit_GetTObj(goHnd);
               TObj(pObj).bSearchEnemy := true;
               _unit_OrderAttack(goHnd, trgHnd, false, true, True); // Need iLockTrg (last bool)
            end;
            Result := trgHnd;
         end;
      end;
   end;
end;

// _ai_ArmyBitvaLink
//
procedure _ai_ArmyBitvaLink(pArmy : Pointer);
begin
   if (pArmy<>nil) then
   begin
      var arch : Integer = _ai_ArmyHandleArchers(pArmy, 1000000);
      var i, j : Integer;
      var inBattle : Boolean;
      var tooFar : Boolean = true;
      var plInd : Integer = TArmy(pArmy).fPlIndex;
      gPlayer[plInd].aiData.aiList.Clear;
      gIntegerList.Clear;
      
      if arch <> 0 then
      gIntegerList.Add(arch);
      
      for i := TArmy(pArmy).fSquadList.GetCount-1 downto 0 do
      begin
         var pSquad : Pointer = TArmy(pArmy).fSquadList.GetPointer(i);
         for j := TSquad(pSquad).GetCount-1 downto 0 do
         begin
            var goHnd : Integer = TSquad(pSquad).Get(j);
            var pObj : Pointer = _unit_GetTObj(goHnd);
            var pObjProp : Pointer = _unit_GetObjProp(goHnd);
            if (not TObjProp(pObjProp).bArtillery) and (not TObjProp(pObjProp).bPriest) and (TObjProp(pObjProp).usage <> gc_obj_usage_archer) then
            begin
               var trgHnd : Integer = GetGameObjectSTOHandleByHandle(goHnd);
               
               if trgHnd = 0 then
               begin
                  TObj(pObj).bSearchEnemy := true;
                  trgHnd := _unit_DoSearchVictim(goHnd, true);
               end;
               
               if (trgHnd <> 0) and (TObj(pObj).orders[0].iType = gc_obj_order_type_attackobj) then
               begin
                  inBattle := true;
                  gIntegerList.Add(trgHnd);
                  var goX : Float = GetGameObjectPositionXByHandle(goHnd);
                  var goZ : Float = GetGameObjectPositionZByHandle(goHnd);
                  var trgX : Float = GetGameObjectPositionXByHandle(trgHnd);
                  var trgZ  : Float = GetGameObjectPositionZByHandle(trgHnd);
                  if VectorDistance(goX, 0, goZ, trgX, 0, trgZ) < TObjProp(pObjProp).searchRadius then
                  tooFar := false;
               end
               else
               gPlayer[plInd].aiData.aiList.Add(goHnd);
            end;
         end;
      end;
      
      if tooFar then
      inBattle := false;
      
      if inBattle or (arch <> 0) then
      begin
         for i := gPlayer[plInd].aiData.aiList.GetCount-1 downto 0 do
         begin
            var goHnd : Integer = gPlayer[plInd].aiData.aiList.Get(i);
            var goX : Float = GetGameObjectPositionXByHandle(goHnd);
            var goZ : Float = GetGameObjectPositionZByHandle(goHnd);
            
            var trgHnd : Integer = GetGameObjectSTOHandleByHandle(goHnd);
            if trgHnd = 0 then
            begin
               var minDist : Float = gc_MaxInt;
               var newHnd : Integer;
               for j := gIntegerList.GetCount-1 downto 0 do
               begin
                  var hnd : Integer = gIntegerList.Get(j);
                  var x : Float = GetGameObjectPositionXByHandle(hnd);
                  var z : Float = GetGameObjectPositionZByHandle(hnd);
                  var dist : Float = VectorDistance(goX, 0, goZ, x, 0, z);
                  if dist < minDist then
                  begin
                     newHnd := hnd;
                     minDist := dist;
                  end;
               end;
               
               if newHnd <> 0 then
               _unit_OrderAttack(goHnd, newHnd, true, true, false);
            end;
         end;
      end
      else
      _ai_ArmyCancelOrders(pArmy);
   end;
end;

// _ai_ArmyBitvaLinkExt
//
procedure _ai_ArmyBitvaLinkExt(pArmy : Pointer; setPos : Boolean; x, z : Float);
begin
   if (pArmy<>nil) then
   begin
      var i, j : Integer;
      var inBattle : Boolean;
      var count : Integer;
      var posX, posZ : Float;
      var mode : Integer = -1;
      var enHnd : Integer;
      
      for i := TArmy(pArmy).fSquadList.GetCount-1 downto 0 do
      begin
         var pSquad : Pointer = TArmy(pArmy).fSquadList.GetPointer(i);
         for j := TSquad(pSquad).GetCount-1 downto 0 do
         begin
            var goHnd : Integer = TSquad(pSquad).Get(j);
            var pObj : Pointer = _unit_GetTObj(goHnd);
            var pObjProp : Pointer = _unit_GetObjProp(goHnd);
            if (not TObjProp(pObjProp).bArtillery) and (not TObjProp(pObjProp).bPriest) and (TObjProp(pObjProp).usage <> gc_obj_usage_archer) and (TObjProp(pObjProp).usage <> gc_obj_usage_grenadier) then // (TObjProp(pObjProp).usage <> gc_obj_usage_grenadier) - experiment
            begin
               var trgHnd : Integer = GetGameObjectSTOHandleByHandle(goHnd);
               
               if trgHnd = 0 then
               begin
                  var curOrder : Integer = _unit_GetCurrentOrder(goHnd);
                  if (curOrder >= 0) and (TObj(pObj).orders[curOrder].iType = gc_obj_order_type_attackobj) then
                  trgHnd := TObj(pObj).orders[curOrder].info.trg;
               end;
               
               if trgHnd = 0 then
               begin
                  TObj(pObj).bSearchEnemy := true;
                  trgHnd := _unit_DoSearchVictim(goHnd, false);
               end;
               
               if trgHnd <> 0 then
               begin
                  // if target is cannon, then unit don't get order to attack it
                  var kill : Boolean = (TObj(pObj).orders[0].iType = gc_obj_order_type_attackobj);
                  if kill then
                  mode := 0
                  else
                  begin
                     var pTrgObjProp : Pointer = _unit_GetObjProp(trgHnd);
                     if TObjProp(pTrgObjProp).bCapture then
                     kill := true;
                     
                     if mode < 0 then
                     begin
                        enHnd := trgHnd;
                        mode := 1;
                     end;
                  end;
                  
                  if kill then
                  begin
                     var trgX : Float = GetGameObjectPositionXByHandle(trgHnd);
                     var trgZ : Float = GetGameObjectPositionZByHandle(trgHnd);
                     posX := posX + trgX;
                     posZ := posZ + trgZ;
                     count := count+1;
                  end;
               end;
            end;
         end;
      end;
      
      if count > 0 then
      begin
         TArmy(pArmy).fOrder.tag := mode;
         
         posX := posX / count;
         posZ := posZ / count;
         
         if mode = 0 then
         begin
            // attack enemy unit
            _unit_SetArmyOrderTarget(pArmy, 0);
            _ai_SetArmyPosition(pArmy, posX, posZ, 0, 0, gc_obj_order_move_mode_attack);
         end
         else
         begin
            // capture enemy unit
            _unit_SetArmyOrderTarget(pArmy, enHnd);
            _ai_SetArmyPosition(pArmy, posX, posZ, 0, 0, gc_obj_order_move_mode_default);
         end;
      end
      else
      begin
         if setPos then
         _ai_SetArmyPosition(pArmy, x, z, 0, 0, gc_obj_order_move_mode_attack)
         else
         _ai_ArmyCancelOrders(pArmy);
      end;
      // IMPORTANT CHANGE
      var arch : Integer = _ai_ArmyHandleArchers(pArmy, 1000000);
   end;
end;

// _ai_ArmyBitva
//
procedure _ai_ArmyBitva(pArmy : Pointer; posX, posZ : Float);
begin
   if (pArmy<>nil) then
   begin
      // TODO: maybe there's necessary to check last battle time
      //if(tmtmt-LastBitvaTime<64||(AOrder&&AOrder->ALink==&A_BitvaLink))return;
      
      if (not TArmy(pArmy).fSpecialOrder) and (TArmy(pArmy).fOrder.iType <> gc_ai_armyorder_bitva) then
      begin
         var i, j : Integer;
         var bitva : Boolean;
         for [MAIN]i := TArmy(pArmy).fSquadList.GetCount-1 downto 0 do
         begin
            var pSquad : Pointer = TArmy(pArmy).fSquadList.GetPointer(i);
            for j := TSquad(pSquad).GetCount-1 downto 0 do
            begin
               var goHnd : Integer = TSquad(pSquad).Get(j);
               var pObj : Pointer = _unit_GetTObj(goHnd);
               if not TObj(pObj).bDead then
               begin
                  bitva := true;
                  break(MAIN);
               end;
            end;
         end;
         
         if bitva then
         begin
            for i := TArmy(pArmy).fSquadList.GetCount-1 downto 0 do
            begin
               var pSquad : Pointer = TArmy(pArmy).fSquadList.GetPointer(i);
               for j := TSquad(pSquad).GetCount-1 downto 0 do
               begin
                  var goHnd : Integer = TSquad(pSquad).Get(j);
                  var pObj : Pointer = _unit_GetTObj(goHnd);
                  TObj(pObj).bsearchenemy := True;
               end;
            end;
            
            TArmy(pArmy).fOrder.iType := gc_ai_armyorder_bitva;
            TArmy(pArmy).fOrder.tag := 0;
            TArmy(pArmy).fLastBattleTime := GetGameTime;
            _ai_ArmyBitvaLinkExt(pArmy, true, posX, posZ);
         end
         else
         if (TArmy(pArmy).fOrder.iType <> gc_ai_armyorder_sabotage) and (TArmy(pArmy).fOrder.iType <> gc_ai_armyorder_agressor) then
         TArmy(pArmy).fOrder.iType := gc_ai_armyorder_none;
      end;
   end;
end;

// _ai_MakeListObjectsInRadiusByUsageBySpiral
//
procedure _ai_MakeListObjectsInRadiusByUsageBySpiral(plind, usage, needcount : Integer; x, y, r : Float; bAllowFood, bcheckdist : Boolean; mmask : Integer; var list : TIntegerList; clearlist : Boolean);
begin
   if clearlist then
   list.Clear;
   var rmmask : Integer;
   if (mmask=0) then
   rmmask := $ffff
   else
   rmmask := mmask;
   var trgHnd : Integer;
   var count : Integer;
   var rSqr : Float = r*r;
   procedure SpiralHelper(gridx, gridy : Integer;{ mmask : Integer;} var list : TIntegerList);
   begin
      if (needcount>0) and (count>=needcount) then exit;
      var i : Integer;
      if ((gScanGrid[gridx, gridy].fMask and rmmask)<>0) and (gScanGrid[gridx, gridy].fPlMask and (1 shl plind)>0) then
      for i:=gScanGrid[gridx, gridy].GetCount-1 downto 0 do
      begin
         trgHnd := gScanGrid[gridx, gridy].Get(i);
         if (trgHnd<>0) then
         begin
            var pobj : Pointer = StateMachineGetArgDataByInd(GetGameObjectStateMachineHandle(trgHnd), gc_argunit_obj); {if (gProfile.bDbgLogPointerNil) then _init_DebugPointerNil(pobj);}
            if (pobj<>nil) and (gObjProp[TObj(pobj).cid][TObj(pobj).id].usage=usage) and (TObj(pobj).pl=plind) and (TObj(pObj).squad=-1) then
            begin
               if (TObj(pobj).orders[0].itype=gc_obj_order_type_gainres) and ((bAllowFood) or (TObj(pobj).orders[0].info.restype<>gc_resource_type_food)) then
               begin
                  if (not bcheckdist) or ((Sqr(GetGameObjectPositionXByHandle(trgHnd)-x)+Sqr(GetGameObjectPositionZByHandle(trgHnd)-y))<=rSqr) then
                  begin
                     list.Add(trgHnd);
                     count := count+1;
                     if (needcount>0) and (count>=needcount) then
                     break;
                  end;
               end;
            end;
         end;
      end;
   end;
   var rx1 : Integer = floor(r/gc_scangrid_size)+1;
   var gridX, gridY : Integer;
   _misc_PosToScanGridIndices(x, y, gridX, gridY);
   
   SpiralHelper(gridX, gridY{, mmask}, list);
   var i, rad : Integer;
   for [MAIN]rad:=1 to rx1 do
   begin
      for i:=-rad to rad do
      begin
         if (needcount>0) and (count>=needcount) then break(MAIN);
         if ((gridY+i)>0) and ((gridY+i)<gc_scangrid_county) then
         begin
            if ((gridX-rad)>0) and ((gridX-rad)<gc_scangrid_countx) then
            SpiralHelper(gridX-rad, gridY+i{, mmask}, list);
            if ((gridX+rad)>0) and ((gridX+rad)<gc_scangrid_countx) then
            SpiralHelper(gridX+rad, gridY+i{, mmask}, list);
         end;
      end;
      
      for i:=-rad to rad do
      begin
         if (needcount>0) and (count>=needcount) then break(MAIN);
         if ((gridX+i)>0) and ((gridX+i)<gc_scangrid_countx) then
         begin
            if ((gridY-rad)>0) and ((gridY-rad)<gc_scangrid_county) then
            SpiralHelper(gridX+i, gridY-rad{, mmask}, list);
            if ((gridY+rad)>0) and ((gridY+rad)<gc_scangrid_county) then
            SpiralHelper(gridX+i, gridY+rad{, mmask}, list);
         end;
      end;
   end;
end;

// _ai_GetClosestOrePlaceWithRes
//
function _ai_GetClosestOrePlaceWithRes(plind : Integer; resid : Integer) : Integer;
begin
   Result := 0;
   var myisland : Integer = _misc_GetIsland(gPlayer[plind].aidata.centerx, gPlayer[plind].aidata.centerz);
   var i : Integer;
   for i:=0 to gPlayer[plind].aidata.orelist.GetCount-1 do
   begin
      var mineHnd : Integer = gPlayer[plind].aidata.orelist.Get(i);
      var pres : Pointer = _res_GetTRes(mineHnd);
      if (pres<>nil) and (TRes(pres).itype=resid) then
      begin
         var mineX : Float = GetGameObjectPositionXByHandle(mineHnd);
         var mineZ : Float = GetGameObjectPositionZByHandle(mineHnd);
         if _misc_IsCorrectIslandPosition(plInd, mineX, mineZ) then
         begin
            Result := mineHnd;
            
            _misc_MakeListObjectsInRadius(minex, minez, 1, false, (1 shl gc_obj_material_building), 1, False, gIntegerList);
            var j : Integer;
            for j:=gIntegerList.GetCount-1 downto 0 do
            begin
               var bldHnd : Integer = gIntegerList.Get(j);
               var bldX : Float = GetGameObjectPositionXByHandle(bldHnd);
               var bldZ : Float = GetGameObjectPositionZByHandle(bldHnd);
               if VectorDistance(minex, 0, minez, bldX, 0, bldZ) < gc_epsilon+0.5 then
               begin
                  Result := 0;
                  break;
               end;
            end;
            
            if (Result<>0) then
            begin
               var dist : Float = VectorDistance(mineX, 0, mineZ, gPlayer[plind].aidata.centerx, 0, gPlayer[plind].aidata.centerz);
               if (dist<gc_ai_dist_mines_expansion) then
               begin
                  var stZone : integer = TopologyGetZoneIndex(gPlayer[plind].aidata.centerx, gPlayer[plind].aidata.centerz);
                  var endZone : Integer = TopologyGetZoneIndex(mineX, mineZ);
                  var flag : Boolean = TopologyGetZonesPath(stZone, endZone);
                  if (flag) then
                  begin
                     var dangerPath : Float = _player_GetTopZoneTrackPointsDanger(plind, endZone);
                     if (dangerPath>1) then
                     Result := 0;
                  end
               end
               else
               Result := 0;
            end;
            if (Result<>0) then
            break;
         end;
      end;
   end;
end;

//returns mine with resid
function _ai_GetCloseMineWithResId(plind : Integer; centerx, centerz : Float; resid : Integer) : Integer;
begin
   Result := 0; //invalid goHnd index, no mine
   var i : Integer;
   for i:=gPlayer[plind].aidata.mines.GetCount-1 downto 0 do
   begin
      var goHnd : Integer = gPlayer[plind].aidata.mines.Get(i);
      var goX : Float = GetGameObjectPositionXByHandle(goHnd);
      var goZ : Float = GetGameObjectPositionZByHandle(goHnd);
      var dist : Float = VectorDistance(goX, 0, centerx, goZ, 0, centerz);
      SetGameObjectTagFloatByHandle(goHnd, dist);
   end;
   _misc_SortListByTagFloat(gPlayer[plind].aidata.mines, 0, gPlayer[plind].aidata.mines.GetCount-1);
   
   for i:=0 to gPlayer[plind].aidata.mines.GetCount-1 do
   begin
      var goHnd : Integer = gPlayer[plind].aidata.mines.Get(i);
      var pobj : Pointer = _unit_GetTObj(goHnd);
      if (pobj<>nil) and (gObjProp[TObj(pobj).cid][TObj(pobj).id].produce[resid]>0) then
      begin
         Result := goHnd;
         break;
      end;
   end;
end;

//_ai_GetFreeBuildingIndex
//
function _ai_GetFreeBuildingIndex(plind : Integer) : Integer;
begin
   Result := -1;
   var i: Integer;
   for i:=0 to gc_ai_max_construction_sites-1 do
   begin
      if (not gPlayer[plind].aidata.buildprojects[i].used) then
      begin
         Result := i;
         break;
      end;
   end;
end;

// _ai_CanUnitAttack
//
function _ai_CanUnitAttack(goHnd : Integer) : Boolean;
begin
   var plHnd : Integer = GetGameObjectPlayerHandleByHandle(goHnd);
   var plInd : Integer = GetPlayerIndexByHandle(plHnd);
   if gPlayer[plInd].bExists then
   begin
      if gPlayer[plInd].bAI then
      begin
         var pObj : Pointer = _unit_GetTObj(goHnd);
         if TObj(pObj).squad >= 0 then
         begin
            var pSquad : Pointer = gPlayer[plInd].squads.Get(TObj(pObj).squad);
            Result := (TSquad(pSquad).fArmy < 0);
         end
         else
         Result := true;
      end
      else
      Result := true;
   end
   else
   Result := false;
end;

//_ai_GetUnitCurrentUpgLevel
//
function _ai_GetUnitCurrentUpgLevel(plind, cid, airole, node : Integer) : Integer;
begin
   var i, id : Integer;
   Result := 0;
   if (node=1) then
   for i:=gPlayer[plind].aidata.unitupg[cid][airole].attackupgrade downto 0 do
   begin
      id := gPlayer[plind].aidata.unitupg[cid][airole].attackupgradeid[i];
      if gPlayer[plind].upgstate[cid][id].done then
      begin
         Result := i;
         break;
      end;
   end
   else
   for i:=gPlayer[plind].aidata.unitupg[cid][airole].defenceupgrade downto 0 do
   begin
      id := gPlayer[plind].aidata.unitupg[cid][airole].defenceupgradeid[i];
      if gPlayer[plind].upgstate[cid][id].done then
      begin
         Result := i;
         break;
      end;
   end;
end;

//_ai_GetUnitCount
//
function _ai_GetUnitCount(plindex, cid, airole : Integer) : Integer;
begin
   Result := gPlayer[plindex].aidata.unitsamount[cid, airole];
end;

// _ai_IsWaterArmy
//
function _ai_IsWaterArmy(pArmy : Pointer) : Boolean;
begin
   Result := False;
   if pArmy <> nil then
   begin
      if TArmy(pArmy).fSquadList.GetCount > 0 then
      begin
         var pSquad : Pointer = TArmy(pArmy).fSquadList.GetPointer(0);
         if pSquad <> nil then
         Result := _squad_IsWaterSquad(pSquad);
      end;
   end;
end;

// _ai_ArmyCanAttack
//
function _ai_ArmyCanAttack(pArmy : Pointer) : Boolean;
begin
   Result := false;
   if (pArmy <> nil) and TArmy(pArmy).fActive then
   begin
      if _ai_IsWaterArmy(pArmy) then
      Result := (TArmy(pArmy).fSpec <> gc_ai_armyspec_transport)
      else
      begin
         var i, j : Integer;
         for [MAIN]i := TArmy(pArmy).fSquadList.GetCount-1 downto 0 do
         begin
            var pSquad : Pointer = TArmy(pArmy).fSquadList.GetPointer(i);
            if pSquad<>nil then
            for j := TSquad(pSquad).GetCount-1 downto 0 do
            begin
               var goHnd : Integer = TSquad(pSquad).Get(j);
               var pObjProp : Pointer = _unit_GetObjProp(goHnd);
               if (not TObjProp(pObjProp).bPriest) and (not TObjProp(pObjProp).bDrummer) then
               begin
                  Result := true;
                  break(MAIN);
               end;
            end;
         end;
      end;
   end;
end;

// _ai_GetDiverArmiesCount
//
function _ai_GetDiverArmiesCount(plInd : Integer) : Integer;
begin
   var i : Integer;
   Result := 0;
   for i := gPlayer[plInd].aiData.armyList.GetCount-1 downto 0 do
   begin
      var pArmy : Pointer = gPlayer[plInd].aiData.armyList.Get(i);
      if (pArmy<>nil) and (TArmy(pArmy).fSpec = gc_ai_armyspec_sabotage) then
      Result := Result+1;
   end;
end;

// _ai_SquadIsArtillery
//
function _ai_SquadIsArtillery(pSquad : Pointer) : Boolean;
begin
   if pSquad <> nil then
   begin
      var aType : Integer = TSquad(pSquad).fType;
      Result := ((aType = gc_ai_armytype_cannon) or (aType = gc_ai_armytype_mortar) or (aType = gc_ai_armytype_supermortar));
   end
   else
   Result := false;
end;

// _ai_ArmyTooStrong
//
function _ai_ArmyTooStrong(pArmy : Pointer) : Boolean;
begin
   if (pArmy<>nil) then
   begin
      var plInd : Integer = TArmy(pArmy).fPlIndex;
      var pEnemyInfo : Pointer = _misc_GetPlayerEnemyInfo(plInd);
      if pEnemyInfo <> nil then
      begin
         if (TArmy(pArmy).fSquadList.GetCount > 3) and (TArmy(pArmy).fForce > TEnemyInfo(pEnemyInfo).maxArmyForce) then
         Result := true
         else
         Result := false;
      end
      else
      Result := false;
   end;
end;

// _ai_ArmyCanMerge
//
function _ai_ArmyCanMerge(pArmy : Pointer) : Boolean;
begin
   if pArmy <> nil then
   begin
      if _ai_IsWaterArmy(pArmy) then
      Result := true
      else
      begin
         Result := (not _ai_ArmyTooStrong(pArmy));
         if Result then
         begin
            var sqCount : Integer = TArmy(pArmy).fSquadList.GetCount;
            var cols : Integer = MathCeil(Sqrt(sqCount));
            var rows : Integer = MathCeil(sqCount/cols);
            
            var height : Float = (rows-1)/2 * TArmy(pArmy).fOffsetRow;
            var width : Float = (cols-1)/2 * TArmy(pArmy).fOffsetCol;
            var maxDist : Float = Sqrt(Sqr(height) + Sqr(width));
            
            var i : Integer;
            for i := TArmy(pArmy).fSquadList.GetCount-1 downto 0 do
            begin
               var pSquad : Pointer = TArmy(pArmy).fSquadList.GetPointer(i);
               var dist : Float = VectorDistance(TSquad(pSquad).fCurX, 0, TSquad(pSquad).fCurZ, TArmy(pArmy).fCurX, 0, TArmy(pArmy).fCurZ);
               if dist > 2 * maxDist then
               begin
                  Result := false;
                  break;
               end;
            end;
         end;
      end;
   end
   else
   Result := false;
end;

// _ai_GetArmyForce
//
function _ai_GetArmyForce(pArmy : Pointer) : Float;
begin
   Result := 0;
   if pArmy <> nil then
   begin
      var i, j : Integer;
      for i := TArmy(pArmy).fSquadList.GetCount-1 downto 0 do
      begin
         var pSquad : Pointer = TArmy(pArmy).fSquadList.GetPointer(i);
         if pSquad<>nil then
         for j := TSquad(pSquad).GetCount-1 downto 0 do
         begin
            var goHnd : Integer = TSquad(pSquad).Get(j);
            var pObj : Pointer = _unit_GetTObj(goHnd);
            Result := Result + gObjProp[TObj(pObj).cid][TObj(pObj).id].aiForce;
         end;
      end;
   end;
end;

// _ai_GetArmyInfoTopZone
//
function _ai_GetArmyInfoTopZone(p : Pointer) : Integer;
begin
   if p <> nil then
   begin
      var aScanX : Float = (TArmyInfo(p).minX + TArmyInfo(p).maxX) / 2;
      var aScanY : Float = (TArmyInfo(p).minY + TArmyInfo(p).maxY) / 2;
      var aX, aY : Float;
      _misc_ScanGridIndicesToPos(aScanX, aScanY, aX, aY);
      Result := TopologyGetZoneIndex(aX, aY);
   end
   else
   Result := -1;
end;

// _ai_IsArmyTransport
//
function _ai_IsArmyTransport(pArmy : Pointer) : Boolean;
begin
   Result := false;
   if (pArmy <> nil) and (TArmy(pArmy).fSquadList.GetCount > 0) then
   begin
      var pSquad : Pointer = TArmy(pArmy).fSquadList.GetPointer(0);
      if pSquad<>nil then
      begin
         var goHnd : Integer = _unit_GetSquadUnit(pSquad);
         if goHnd <> 0 then
         begin
            var pObjProp : Pointer = _unit_GetObjProp(goHnd);
            Result := (TObjProp(pObjProp).transport > 0);
         end;
      end;
   end;
end;

// _ai_ArmyOrderTransport
//
procedure _ai_ArmyOrderTransport(pArmy : Pointer);
begin
   if pArmy <> nil then
   TArmy(pArmy).fOrder.iType := gc_ai_armyorder_transport;
end;

// _ai_TestArmyBrushPosition
//
function _ai_TestArmyBrushPosition(pArmy : Pointer; posX, posZ, dirX, dirZ : Float; setPos : Boolean) : Integer;
begin
   Result := 0;
   if pArmy <> nil then
   begin
      var plInd : Integer = TArmy(pArmy).fPlIndex;
      var plHnd : Integer = GetPlayerHandleByIndex(plInd);
      if plHnd <> 0 then
      begin
         ClearPlayerStretchBrushGroups(plHnd);
         var i : Integer;
         var count : Integer = TArmy(pArmy).fSquadList.GetCount;
         for i := 0 to count-1 do
         begin
            var pSquad : Pointer = TArmy(pArmy).fSquadList.GetPointer(i);
            if pSquad<>nil then
            begin
               var grHnd : Integer = _squad_GetGroupHandle(pSquad);
               if grHnd <> 0 then
               AddPlayerStretchBrushGroupHandle(grHnd);
            end;
         end;
         
         SLogicFrmRotateSetUsePointFormation(false);
         SLogicFrmRotateSetUseLinesFormation(true);
         
         SLogicFrmRotateSetStaticDir(False);
         ProcessPlayerSLogicFrmRotate(plHnd, posX, posZ, dirX, dirZ, true);
         ApplyPlayerStretchBrush(plHnd);
         
         for i := GetPlayerStretchBrushGroupsCount(plHnd)-1 downto 0 do
         begin
            var pSquad : Pointer = TArmy(pArmy).fSquadList.GetPointer(i);
            if pSquad<>nil then
            begin
               var grHnd : Integer = GetPlayerStretchBrushGroupHandleByIndex(plHnd, i);
               var grX : Float = GetPlayerStretchBrushGroupTargetPositionX(grHnd);
               var grY : Float = GetPlayerStretchBrushGroupTargetPositionY(grHnd);
               var grDirX, grDirY, grDirZ : Float;
               var angle : Float = GetPlayerStretchBrushGroupTargetAngle(grHnd);
               GetStretchBrushDirByAngle(angle, grDirX, grDirZ);
               
               var realX, realY : Float;
               GetGroupUncollidedPositionByHandle(grHnd, grX, grY, -1, realX, realY);
               var mode : Integer;
               
               if (realX <> grX) or (realY <> grY) then
               begin
                  grDirX := grX-realX;
                  grDirY := 0;
                  grDirZ := grY-realY;
                  VectorNormalize(grDirX, grDirY, grDirZ);
               end;
               
               if _ai_IsArmyTransport(pArmy) then
               begin
                  var goHnd : Integer = TSquad(pSquad).Get(0);
                  var minY : Float = GroupGetMinYByHandle(grHnd);
                  var trX : Float = realX - minY * grDirX / 2;
                  var trZ : Float = realY - minY * grDirZ / 2;
                  
                  if _unit_TestTransportPosition(goHnd, trX, trZ, grDirX, grDirZ) then
                  begin
                     mode := gc_obj_order_move_mode_landing;
                     
                     var goX : Float = GetGameObjectPositionXByHandle(goHnd);
                     var goZ : Float = GetGameObjectPositionZByHandle(goHnd);
                     if TopologyGetPathDistance(goX, goZ, trX, trZ, false) > 0 then
                     Result := Result+1;
                  end
                  else
                  mode := gc_obj_order_move_mode_default;
               end
               else
               mode := gc_obj_order_move_mode_default;
               
               if setPos then
               begin
                  var sqInd : Integer = TSquad(pSquad).fIndex;
                  _player_SetGroupPosition(plHnd, grHnd, sqInd, realX, realY, grX, grY, grDirX, grDirZ, false, false, false, false, mode);
               end;
            end;
         end;
      end;
   end;
end;

// _ai_SetArmyBrushPosition
//
procedure _ai_SetArmyBrushPosition(pArmy : Pointer; posX, posZ, dirX, dirZ : Float);
begin
   _ai_TestArmyBrushPosition(pArmy, posX, posZ, dirX, dirZ, true);
end;

// _ai_GetArmyType
//
function _ai_GetArmyType(pArmy : Pointer) : Integer;
begin
   Result := gc_ai_armytype_none;
   if (pArmy <> nil) and (TArmy(pArmy).fSquadList.GetCount > 0) then
   begin
      var pSquad : Pointer = TArmy(pArmy).fSquadList.GetPointer(0);
      if pSquad <> nil then
      Result := TSquad(pSquad).fType;
   end;
end;

// _ai_GetArmyIsland
//
function _ai_GetArmyIsland(pArmy : Pointer) : Integer;
begin
   if (pArmy <> nil) and (not _ai_IsWaterArmy(pArmy)) then
   begin
      var posX : Float = TArmy(pArmy).fCurX;
      var posZ : Float = TArmy(pArmy).fCurZ;
      var island : Integer = _misc_GetIsland(posX, posZ);
      if island >= 0 then
      Result := island
      else
      begin
         var i, j : Integer;
         for i := TArmy(pArmy).fSquadList.GetCount-1 downto 0 do
         begin
            var pSquad : Pointer = TArmy(pArmy).fSquadList.GetPointer(i);
            if pSquad<>nil then
            for j := TSquad(pSquad).GetCount-1 downto 0 do
            begin
               var goHnd : Integer = TSquad(pSquad).Get(j);
               posX := GetGameObjectPositionXByHandle(goHnd);
               posZ := GetGameObjectPositionZByHandle(goHnd);
               island := _misc_GetIsland(posX, posZ);
               if island >= 0 then
               begin
                  Result := island;
                  exit;
               end;
            end;
         end;
         
         Result := -1;
      end;
   end
   else
   Result := -1;
end;

// _ai_GetEnemyArmyIsland
//
function _ai_GetEnemyArmyIsland(pEnArmy : Pointer) : Integer;
begin
   if (pEnArmy <> nil) and (TArmyInfo(pEnArmy).landCount > 0) then
   begin
      var posX, posZ : Float;
      var gridX : Float = (TArmyInfo(pEnArmy).minX + TArmyInfo(pEnArmy).maxX) / 2;
      var gridY : Float = (TArmyInfo(pEnArmy).minY + TArmyInfo(pEnArmy).maxY) / 2;
      _misc_ScanGridIndicesToPos(gridX, gridY, posX, posZ);
      
      var island : Integer = _misc_GetIsland(posX, posZ);
      if island >= 0 then
      Result := island
      else
      begin
         var minX, minY, maxX, maxY : Float;
         _misc_ScanGridIndicesToPos(TArmyInfo(pEnArmy).minX, TArmyInfo(pEnArmy).minY, minX, minY);
         _misc_ScanGridIndicesToPos(TArmyInfo(pEnArmy).maxX, TArmyInfo(pEnArmy).maxY, maxX, maxY);
         
         var w : Integer = GetMapWidth;
         var h : Integer = GetMapHeight;
         var i, j : Integer;
         
         var minI : Integer = Floor(2*minX) + w;
         var maxI : Integer = Floor(2*maxX) + w;
         var minJ : Integer = Floor(2*minY) + h;
         var maxJ : Integer = Floor(2*maxY) + h;
         
         for i := minI to maxI do
         for j := minJ to maxJ do
         if gIslands.grid[i, j].index >= 0 then
         begin
            Result := gIslands.grid[i, j].index;
            exit;
         end;
         
         Result := -1;
      end;
   end
   else
   Result := -1;
end;

// _ai_FindMoorPosition
//
function _ai_FindMoorPosition(pArmy : Pointer; x, z : Float) : Boolean;
begin
   const tryCount = 10;
   const rad = 7;
   
   Result := false;
   var island : Integer = _misc_GetIsland(x, z);
   var i, landing : Integer;
   for i := 0 to tryCount-1 do
   begin
      var dx : Float = (2*RandomExt-1) * rad;
      var dz : Float = (2*RandomExt-1) * rad;
      if _misc_GetIsland(x+dx, z+dz) = island then
      begin
         landing := _ai_TestArmyBrushPosition(pArmy, x+dx, z+dz, 0, 0, false);
         if landing > 0 then
         begin
            _ai_SetArmyBrushPosition(pArmy, x+dx, z+dz, 0, 0);
            Result := true;
            exit;
         end;
      end;
   end;
end;
